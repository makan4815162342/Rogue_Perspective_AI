import bpy
from bpy.props import (
    PointerProperty, StringProperty, FloatProperty,
    IntProperty, BoolProperty, EnumProperty, FloatVectorProperty
)
from bpy.types import Operator, Panel, PropertyGroup
import math
from mathutils import Vector
import random
from bpy_extras.object_utils import world_to_camera_view # For camera trimming

# --- START OF FILE Rogue Perspective AI Mixed.txt ---

bl_info = {
    "name": "Rogue Perspective AI",
    "author": "Your Name & Gemini & Copilot",
    "version": (0, 4, 7), # Incremented version for this fix
    "blender": (4, 0, 0),
    "location": "View3D > Sidebar > RogueAI",
    "description": "Assists with creating perspective curve guides. (VP persistence, 1P Z-freedom, stability attempts)",
    "warning": "If crashes occur on mode switch, check console for errors.",
    "doc_url": "",
    "category": "3D View",
}

# ... (Keep all your existing Global Variables, Utility Functions, Callbacks, Properties, etc. from line 18 down to line 548)
# Global Variables / Constants
# -----------------------------------------------------------
PERSPECTIVE_HELPER_COLLECTION = "Perspective_Helpers_Collection"
PERSPECTIVE_GUIDES_COLLECTION = "Perspective_Guides_Curves_Collection"
HORIZON_CTRL_OBJ_NAME = "CTRL_Perspective_Horizon"
HORIZON_CURVE_OBJ_NAME = "VISUAL_Horizon_Line"
VP_PREFIX = "VP_"
DEFAULT_LINE_EXTENSION = 100.0

VP_TYPE_SPECIFIC_PREFIX_MAP = {
    'ONE_POINT': VP_PREFIX + "1P",
    'TWO_POINT': VP_PREFIX + "2P",
    'THREE_POINT_H': VP_PREFIX + "3P_H",
    'THREE_POINT_V': VP_PREFIX + "3P_V",
    'FISH_EYE': VP_PREFIX + "FE_Center" # Note: Used as base, often with _1 or specific name
}
previous_perspective_type_on_switch = 'NONE'

# -----------------------------------------------------------
# Utility Functions
# -----------------------------------------------------------
def get_helpers_collection(context):
    if PERSPECTIVE_HELPER_COLLECTION not in bpy.data.collections:
        coll = bpy.data.collections.new(PERSPECTIVE_HELPER_COLLECTION)
        context.scene.collection.children.link(coll)
    return bpy.data.collections[PERSPECTIVE_HELPER_COLLECTION]

def get_guides_collection(context):
    if PERSPECTIVE_GUIDES_COLLECTION not in bpy.data.collections:
        coll = bpy.data.collections.new(PERSPECTIVE_GUIDES_COLLECTION)
        context.scene.collection.children.link(coll)
    return bpy.data.collections[PERSPECTIVE_GUIDES_COLLECTION]

def get_horizon_control_object():
    return bpy.data.objects.get(HORIZON_CTRL_OBJ_NAME)

def get_horizon_curve_object():
    return bpy.data.objects.get(HORIZON_CURVE_OBJ_NAME)

def get_vanishing_points(specific_prefix_key=None):
    vps = []
    if PERSPECTIVE_HELPER_COLLECTION not in bpy.data.collections:
        return []
    helpers_coll = bpy.data.collections[PERSPECTIVE_HELPER_COLLECTION]
    target_prefix = None
    if specific_prefix_key and specific_prefix_key in VP_TYPE_SPECIFIC_PREFIX_MAP:
        target_prefix = VP_TYPE_SPECIFIC_PREFIX_MAP[specific_prefix_key]

    for obj in helpers_coll.objects:
        if obj.type == 'EMPTY' and obj.name.startswith(VP_PREFIX): # General VP_ check
            if target_prefix: # If a specific type is requested
                if obj.name.startswith(target_prefix): # Check if obj name starts with specific type's prefix
                    vps.append(obj)
            else: # If no specific type, get all VPs
                vps.append(obj)

    # Sort VPs by name for consistent order, crucial for 2P/3P auto-assignment if names aren't exact _1, _2
    vps.sort(key=lambda vp_obj: vp_obj.name)
    return vps


def update_material_color_and_opacity(material, new_color_rgb, new_opacity):
    if material and material.node_tree:
        mix_shader_node = next((n for n in material.node_tree.nodes if n.type == 'ShaderNodeMixShader'), None)
        emission_node = next((n for n in material.node_tree.nodes if n.type == 'ShaderNodeEmission'), None)
        if emission_node:
            emission_node.inputs['Color'].default_value = list(new_color_rgb) + [1.0] # RGBA for emission color
        if mix_shader_node:
            mix_shader_node.inputs[0].default_value = new_opacity # Factor for mix shader
        material.diffuse_color = tuple(list(new_color_rgb) + [new_opacity]) # For viewport display (solid mode)
        return True
    return False

def create_curve_object(context, name, points_data_list, collection,
                        bevel_depth=0.01, opacity=1.0, color_rgb=None, # MODIFIED: Added optional color_rgb=None
                        is_cyclic=False, curve_type='POLY'):
    # Remove existing object and its curve data if it's the only user
    if name in bpy.data.objects:
        old_obj = bpy.data.objects[name]
        if old_obj.data and old_obj.data.name in bpy.data.curves and old_obj.data.users <= 1:
            bpy.data.curves.remove(old_obj.data)
        try:
            bpy.data.objects.remove(old_obj, do_unlink=True)
        except ReferenceError:
            pass 

    curve_data = bpy.data.curves.new(name=f"{name}_Data", type='CURVE')
    curve_data.dimensions = '3D'
    curve_data.bevel_depth = bevel_depth
    curve_data.bevel_resolution = 1 
    splines_created_count = 0

    for spline_pts in points_data_list:
        if not spline_pts: continue
        if curve_type == 'POLY' and len(spline_pts) < 2: continue
        if curve_type == 'BEZIER' and not spline_pts: continue

        spline = curve_data.splines.new(type=curve_type)
        if curve_type == 'POLY':
            spline.points.add(len(spline_pts) - 1)
            for idx, pt_co in enumerate(spline_pts):
                spline.points[idx].co = list(pt_co) + [1.0] 
        elif curve_type == 'BEZIER':
            spline.bezier_points.add(len(spline_pts) -1 if spline_pts else 0)
            for idx, pt_co in enumerate(spline_pts):
                bp = spline.bezier_points[idx]
                bp.co = pt_co
                bp.handle_left_type = 'AUTO'
                bp.handle_right_type = 'AUTO'
        
        if spline_pts : 
            spline.use_cyclic_u = is_cyclic and (len(spline_pts) > 1)
        splines_created_count += 1

    if splines_created_count == 0: 
        if curve_data.name in bpy.data.curves:
            bpy.data.curves.remove(curve_data)
        return None

    curve_obj = bpy.data.objects.new(name, curve_data)
    
    # MODIFIED: Determine color to use
    final_color_rgb = color_rgb if color_rgb is not None else \
                      (random.uniform(0.1, 1.0), random.uniform(0.1, 1.0), random.uniform(0.1, 1.0))

    mat_name = f"MAT_{name.replace(':', '_').replace(' ', '_')}" 
    mat = bpy.data.materials.get(mat_name)
    if not mat:
        mat = bpy.data.materials.new(name=mat_name)
        mat.use_nodes = True
        if mat.node_tree:
            mat.node_tree.nodes.clear()
            output_node = mat.node_tree.nodes.new(type='ShaderNodeOutputMaterial')
            transparent_node = mat.node_tree.nodes.new(type='ShaderNodeBsdfTransparent')
            emission_node = mat.node_tree.nodes.new(type='ShaderNodeEmission')
            mix_shader_node = mat.node_tree.nodes.new(type='ShaderNodeMixShader')

            emission_node.inputs['Color'].default_value = list(final_color_rgb) + [1.0] # MODIFIED to use final_color_rgb
            emission_node.inputs['Strength'].default_value = 3.0 
            mix_shader_node.inputs[0].default_value = opacity 

            mat.node_tree.links.new(transparent_node.outputs['BSDF'], mix_shader_node.inputs[1])
            mat.node_tree.links.new(emission_node.outputs['Emission'], mix_shader_node.inputs[2])
            mat.node_tree.links.new(mix_shader_node.outputs['Shader'], output_node.inputs['Surface'])

        mat.blend_method = 'BLEND' 
        if hasattr(mat, "shadow_method"): mat.shadow_method = 'NONE'
        mat.diffuse_color = tuple(list(final_color_rgb) + [opacity]) # MODIFIED to use final_color_rgb
    else: 
        update_material_color_and_opacity(mat, final_color_rgb, opacity) # MODIFIED to use final_color_rgb

    if curve_obj.data.materials: 
        curve_obj.data.materials[0] = mat
    else:
        curve_obj.data.materials.append(mat)

    target_collection = collection if collection else get_guides_collection(context)
    target_collection.objects.link(curve_obj)
    return curve_obj

def clear_guides_with_prefix(context, prefix_list):
    guides_coll = get_guides_collection(context) # Ensures collection exists
    removed_count = 0
    for obj in list(guides_coll.objects): # Iterate over a copy for safe removal
        for prefix in prefix_list:
            if obj.name.startswith(prefix):
                try:
                    if obj.data and obj.data.name in bpy.data.curves and obj.data.users <= 1:
                        bpy.data.curves.remove(obj.data)
                except ReferenceError: pass
                except Exception as e: print(f"Error removing curve data for {obj.name}: {e}")
                try:
                    bpy.data.objects.remove(obj, do_unlink=True)
                    removed_count += 1
                except ReferenceError: pass
                except Exception as e: print(f"Error removing object {obj.name}: {e}")
                break 
    return removed_count

def generate_radial_lines_in_plane(vp_loc, density, line_extension, plane='XZ'):
    lines = []
    if density <= 0: return lines
    for i in range(density):
        angle = 2 * math.pi * i / density
        if plane == 'XY': dir_vec = Vector((math.cos(angle), math.sin(angle), 0))
        elif plane == 'XZ': dir_vec = Vector((math.cos(angle), 0, math.sin(angle)))
        elif plane == 'YZ': dir_vec = Vector((0, math.cos(angle), math.sin(angle)))
        else: dir_vec = Vector((math.cos(angle), math.sin(angle), 0)) # Fallback
        dir_vec.normalize()
        lines.append([vp_loc.copy(), vp_loc + dir_vec * line_extension])
    return lines

# -----------------------------------------------------------
# Dynamic Horizon Line Update
# -----------------------------------------------------------
def update_dynamic_horizon_line_curve(context):
    if not hasattr(context.scene, "perspective_tool_settings_splines"):
        return
    tool_settings = context.scene.perspective_tool_settings_splines
    horizon_curve_obj = get_horizon_curve_object()
    if not horizon_curve_obj:
        return

    current_type = tool_settings.current_perspective_type
    points_world = []
    # Hide by default – we'll unhide it when we set valid points.
    horizon_curve_obj.hide_set(True)

    if current_type == 'ONE_POINT':
        vp1p = get_vanishing_points('ONE_POINT')
        if vp1p:
            z_level = vp1p[0].location.z
            center_x = vp1p[0].location.x
            center_y = vp1p[0].location.y
        else:
            # Fallback to horizon control if needed
            horizon_ctrl = get_horizon_control_object()
            if not horizon_ctrl:
                return
            z_level = horizon_ctrl.location.z
            center_x, center_y = 0, 0
        hz_len = tool_settings.horizon_line_length / 2.0
        points_world = [
            Vector((center_x - hz_len, center_y, z_level)),
            Vector((center_x + hz_len, center_y, z_level))
        ]
        horizon_curve_obj.location = (0, 0, 0)
        horizon_curve_obj.rotation_euler = (0, 0, 0)
        # Explicitly unhide the horizon line for ONE_POINT mode.
        horizon_curve_obj.hide_set(False)

    elif current_type == 'TWO_POINT':
        vps_2p = get_vanishing_points('TWO_POINT')
        if len(vps_2p) >= 2:
            points_world = [
                vps_2p[0].location.copy(),
                vps_2p[1].location.copy()
            ]
            horizon_curve_obj.location = Vector((0, 0, 0))
            horizon_curve_obj.hide_set(False)

    elif current_type == 'THREE_POINT': # Corrected from THREE_POINT to THREE_POINT_H as per get_vanishing_points usage
        vps_3p_h = get_vanishing_points('THREE_POINT_H')
        if len(vps_3p_h) >= 2:
            points_world = [
                vps_3p_h[0].location.copy(),
                vps_3p_h[1].location.copy()
            ]
            horizon_curve_obj.location = Vector((0, 0, 0))
            horizon_curve_obj.hide_set(False)

    # Update the spline for the horizon line, if the data exists.
    if horizon_curve_obj.data and horizon_curve_obj.data.splines:
        if not horizon_curve_obj.data.splines: # Ensure spline exists
             horizon_curve_obj.data.splines.new('POLY')

        spline = horizon_curve_obj.data.splines[0]
        if len(points_world) == 2:
            if len(spline.points) != 2:
                #spline.points.clear() # Not a valid method for SplinePoints
                while len(spline.points) > 0:
                    spline.points.remove(spline.points[0])
                spline.points.add(1)   # Adding one point creates a total of 2 points.
            spline.points[0].co = list(points_world[0]) + [1.0]
            spline.points[1].co = list(points_world[1]) + [1.0]
        else: # Default to origin if no valid points
            if len(spline.points) != 2:
                while len(spline.points) > 0:
                    spline.points.remove(spline.points[0])
                spline.points.add(1)
            spline.points[0].co = (0, 0, 0, 1)
            spline.points[1].co = (0, 0, 0, 1)

    horizon_curve_obj.data.bevel_depth = tool_settings.horizon_line_thickness

    h_color_rgb = list(tool_settings.horizon_line_color[:3])
    h_opacity = tool_settings.horizon_line_color[3]
    mat_to_update = None
    if horizon_curve_obj.active_material:
        mat_to_update = horizon_curve_obj.active_material
    elif horizon_curve_obj.data.materials:
        mat_to_update = horizon_curve_obj.data.materials[0]
    if mat_to_update:
        update_material_color_and_opacity(mat_to_update, h_color_rgb, h_opacity)


# -----------------------------------------------------------
# Property Update Callbacks
# -----------------------------------------------------------
def update_vp_empty_colors(self, context): # self is PerspectiveToolSettingsSplines
    tool_settings = self
    vps_1p = get_vanishing_points('ONE_POINT')
    if vps_1p: vps_1p[0].color = list(tool_settings.one_point_vp_empty_color)

    vps_2p = get_vanishing_points('TWO_POINT') # Already sorted by name
    vp1_2p_target = VP_TYPE_SPECIFIC_PREFIX_MAP['TWO_POINT'] + "_1"
    vp2_2p_target = VP_TYPE_SPECIFIC_PREFIX_MAP['TWO_POINT'] + "_2"
    if len(vps_2p) > 0 and vps_2p[0].name.startswith(vp1_2p_target): vps_2p[0].color = list(tool_settings.two_point_vp1_empty_color)
    elif len(vps_2p) > 0: vps_2p[0].color = list(tool_settings.two_point_vp1_empty_color) # Fallback for first
    if len(vps_2p) > 1 and vps_2p[1].name.startswith(vp2_2p_target): vps_2p[1].color = list(tool_settings.two_point_vp2_empty_color)
    elif len(vps_2p) > 1: vps_2p[1].color = list(tool_settings.two_point_vp2_empty_color) # Fallback for second


    vps_3ph = get_vanishing_points('THREE_POINT_H') # Sorted
    vp1_3ph_target = VP_TYPE_SPECIFIC_PREFIX_MAP['THREE_POINT_H'] + "_1"
    vp2_3ph_target = VP_TYPE_SPECIFIC_PREFIX_MAP['THREE_POINT_H'] + "_2"
    if len(vps_3ph) > 0 and vps_3ph[0].name.startswith(vp1_3ph_target): vps_3ph[0].color = list(tool_settings.three_point_vp_h1_empty_color)
    elif len(vps_3ph) > 0: vps_3ph[0].color = list(tool_settings.three_point_vp_h1_empty_color)
    if len(vps_3ph) > 1 and vps_3ph[1].name.startswith(vp2_3ph_target): vps_3ph[1].color = list(tool_settings.three_point_vp_h2_empty_color)
    elif len(vps_3ph) > 1: vps_3ph[1].color = list(tool_settings.three_point_vp_h2_empty_color)

    vps_3pv = get_vanishing_points('THREE_POINT_V') # Sorted
    vp1_3pv_target = VP_TYPE_SPECIFIC_PREFIX_MAP['THREE_POINT_V'] + "_1"
    if vps_3pv and vps_3pv[0].name.startswith(vp1_3pv_target) : vps_3pv[0].color = list(tool_settings.three_point_vp_v_empty_color)
    elif vps_3pv : vps_3pv[0].color = list(tool_settings.three_point_vp_v_empty_color)

    vps_fe = get_vanishing_points('FISH_EYE')
    if vps_fe: # Should typically only be one for FE center
        # Apply color to all found FE VPs, though usually there's just one primary.
        for vp_fe in vps_fe:
            vp_fe.color = list(tool_settings.fish_eye_vp_empty_color)


    if context.area: context.area.tag_redraw()

def update_guides_visuals_from_props(self, context): # self is PerspectiveToolSettingsSplines
    tool_settings = self # self is PerspectiveToolSettingsSplines
    guides_coll = get_guides_collection(context)
    
    # Opacity and thickness are still global
    default_opacity = tool_settings.guide_curves_opacity
    # Thickness is handled by create_curve_object's bevel_depth and operator generate functions reading guide_curves_thickness

    for obj in guides_coll.objects:
        if obj.type == 'CURVE' and obj.name != HORIZON_CURVE_OBJ_NAME:
            if obj.data: # Update bevel depth (thickness)
                obj.data.bevel_depth = tool_settings.guide_curves_thickness

            mat = obj.active_material if obj.active_material else (obj.data.materials[0] if obj.data.materials else None)
            if mat:
                # Color is set randomly at creation, so we only update opacity here
                # Retrieve the existing emission color to preserve it
                emission_node = next((n for n in mat.node_tree.nodes if n.type == 'ShaderNodeEmission'), None)
                if emission_node:
                    existing_rgb_color = list(emission_node.inputs['Color'].default_value[:3])
                    update_material_color_and_opacity(mat, existing_rgb_color, default_opacity)
    if context.area: context.area.tag_redraw()

def update_horizon_visuals_from_props(self, context):
    update_dynamic_horizon_line_curve(context)

def update_horizon_control_from_prop(self, context): # self is horizon_y_level property
    horizon_ctrl = get_horizon_control_object()
    if horizon_ctrl:
        if abs(horizon_ctrl.location.z - self.horizon_y_level) > 0.001: # self here is PerspectiveToolSettingsSplines
            horizon_ctrl.location.z = self.horizon_y_level
    update_dynamic_horizon_line_curve(context)

def switch_perspective_type_prop(self, context): # self is PerspectiveToolSettingsSplines
    global previous_perspective_type_on_switch
    tool_settings = self
    current_new_type = tool_settings.current_perspective_type
    print(f"Switching from '{previous_perspective_type_on_switch}' to '{current_new_type}'")

    if previous_perspective_type_on_switch != 'NONE' and previous_perspective_type_on_switch != current_new_type:
        print(f"  Clearing guides for previous type: {previous_perspective_type_on_switch}")
        try:
            bpy.ops.perspective_splines.clear_type_guides('EXEC_DEFAULT', type_filter_prop=previous_perspective_type_on_switch)
        except Exception as e: print(f"  Error clearing guides for {previous_perspective_type_on_switch}: {e}")

    try:
        if current_new_type == 'ONE_POINT':
            PERSPECTIVE_OT_generate_one_point_splines.create_default_one_point(context)
        elif current_new_type == 'TWO_POINT':
            # Directly call the class method responsible for creating/checking 2P VPs
            PERSPECTIVE_OT_create_2p_vps_if_needed.create_default_two_point_vps(context) 
        elif current_new_type == 'THREE_POINT':
            PERSPECTIVE_OT_create_3p_vps_if_needed.create_default_three_point_vps(context) # NEW
        elif current_new_type == 'FISH_EYE':
            PERSPECTIVE_OT_generate_fish_eye_splines.create_default_fish_eye_center(context)
    except Exception as e: print(f"  Error creating default VPs for {current_new_type}: {e}")
    
    try: update_vp_empty_colors(tool_settings, context)
    except Exception as e: print(f"  Error updating VP colors: {e}")
    try: update_dynamic_horizon_line_curve(context)
    except Exception as e: print(f"  Error updating horizon line: {e}")

    previous_perspective_type_on_switch = current_new_type
    if context.area: context.area.tag_redraw()
    print(f"Switch to {current_new_type} finished.")

# -----------------------------------------------------------
# Custom Properties
# -----------------------------------------------------------

class PerspectiveToolSettingsSplines(PropertyGroup):
    horizon_y_level: FloatProperty(name="1P Horizon Z", default=0.0, update=update_horizon_control_from_prop, description="Z-level for the 1P horizon line control object")
    horizon_line_length: FloatProperty(name="1P Horizon Length", default=200.0, min=1.0, update=update_horizon_visuals_from_props)
    horizon_line_thickness: FloatProperty(name="Horizon Thickness", default=0.02, min=0.001, max=0.5, update=update_horizon_visuals_from_props)
    horizon_line_color: FloatVectorProperty(name="Horizon Color", subtype='COLOR_GAMMA', size=4, default=(0.9, 0.9, 0.2, 1.0), min=0.0, max=1.0, update=update_horizon_visuals_from_props) # Horizon line keeps its color

    guide_curves_thickness: FloatProperty(name="Guide Lines Thickness", default=0.01, min=0.001, max=0.5, update=update_guides_visuals_from_props)
    guide_curves_opacity: FloatProperty(name="Guide Lines Opacity", default=0.8, min=0.0, max=1.0, subtype='FACTOR', update=update_guides_visuals_from_props)

    # VP Empty colors (for the Empty objects themselves, not the lines)
    one_point_vp_empty_color: FloatVectorProperty(name="1P VP Empty Color", subtype='COLOR', size=4, default=(1.0, 0.7, 0.2, 1.0), min=0.0, max=1.0, update=update_vp_empty_colors)
    two_point_vp1_empty_color: FloatVectorProperty(name="2P VP1 Empty Color", subtype='COLOR', size=4, default=(1.0, 0.4, 0.4, 1.0), min=0.0, max=1.0, update=update_vp_empty_colors)
    two_point_vp2_empty_color: FloatVectorProperty(name="2P VP2 Empty Color", subtype='COLOR', size=4, default=(0.4, 1.0, 0.4, 1.0), min=0.0, max=1.0, update=update_vp_empty_colors)
    three_point_vp_h1_empty_color: FloatVectorProperty(name="3P VP H1 Empty Color", subtype='COLOR', size=4, default=(1.0, 0.2, 0.2, 1.0), min=0.0, max=1.0, update=update_vp_empty_colors)
    three_point_vp_h2_empty_color: FloatVectorProperty(name="3P VP H2 Empty Color", subtype='COLOR', size=4, default=(0.2, 1.0, 0.2, 1.0), min=0.0, max=1.0, update=update_vp_empty_colors)
    three_point_vp_v_empty_color: FloatVectorProperty(name="3P VP V Empty Color", subtype='COLOR', size=4, default=(0.2, 0.2, 1.0, 1.0), min=0.0, max=1.0, update=update_vp_empty_colors)

    # --- One Point ---
    one_point_grid_density_radial: IntProperty(name="Radial Lines Density", default=16, min=2)
    one_point_grid_density_ortho_x: IntProperty(name="Horiz. Parallels Density", default=7, min=0)
    one_point_grid_density_ortho_y: IntProperty(name="Vert. Parallels Density", default=7, min=0)
    one_point_draw_radial: BoolProperty(name="Draw Radial Lines", default=True) # This can stay if you have a single "Generate 1P" button
    one_point_draw_ortho_x: BoolProperty(name="Draw Horiz. Parallels", default=True)
    one_point_draw_ortho_y: BoolProperty(name="Draw Vert. Parallels", default=True)
    one_point_grid_extent: FloatProperty(name="Ortho Grid Extent Factor", default=1.0, min=0.1)
    one_point_line_extension: FloatProperty(name="Radial Line Length", default=DEFAULT_LINE_EXTENSION, min=1.0)

    # --- Two Point ---
    two_point_grid_density_vp1: IntProperty(name="VP1 Lines Density", default=10, min=1) # Renamed for clarity
    two_point_grid_density_vp2: IntProperty(name="VP2 Lines Density", default=10, min=1) # Renamed
    two_point_grid_density_vertical: IntProperty(name="Vertical Lines Density", default=9, min=0)
    # two_point_draw_vp1, _vp2, _vertical can be removed if we have separate buttons for these
    two_point_verticals_x_spacing_factor: FloatProperty(name="Verticals X Spacing Factor", default=1.0, min=0.1, max=5.0)
    two_point_grid_height: FloatProperty(name="Vertical Line Height", default=20.0, min=0.1)
    two_point_grid_depth_offset: FloatProperty(name="Verticals' Y Plane Offset", default=0.0)
    two_point_line_extension: FloatProperty(name="Radial Line Length", default=200.0, min=1.0)

    # --- Three Point ---
    # three_point_draw_grid can be removed if we have separate buttons
    three_point_line_extension: FloatProperty(name="Radial Line Length", default=200.0, min=1.0)
    three_point_vp_h1_density: IntProperty(name="H1 Lines Density", default=8, min=1) # Renamed
    three_point_vp_h2_density: IntProperty(name="H2 Lines Density", default=8, min=1) # Renamed
    three_point_vp_v_density: IntProperty(name="V Lines Density", default=8, min=1)  # Renamed

    # --- Fish Eye ---
    fish_eye_vp_empty_color: FloatVectorProperty(name="FE VP Empty Color", subtype='COLOR', size=4, default=(0.5, 0.2, 0.8, 1.0), min=0.0, max=1.0, update=update_vp_empty_colors) # New for FE VP
    fish_eye_strength: FloatProperty(name="Distortion Strength", default=0.5, min=-1.0, max=1.0) # Currently unused in generation
    fish_eye_grid_radial: IntProperty(name="Longitude Lines", default=16, min=3)
    fish_eye_grid_concentric: IntProperty(name="Latitude Lines", default=8, min=1)
    fish_eye_grid_radius: FloatProperty(name="Sphere Radius", default=15.0, min=0.1)
    fish_eye_segments_per_curve: IntProperty(name="Curve Smoothness", default=24, min=4, max=64)
    fish_eye_draw_latitude: BoolProperty(name="Draw Latitude Lines", default=True) # Defaulted to True as color is gone
    fish_eye_horizontal_scale: FloatProperty(name="Fish Eye Horizontal Scale", default=1.0, min=0.1, max=5.0)

    current_perspective_type: EnumProperty(
        name="Perspective Mode",
        items=[('NONE', "None", "No perspective guides active"),
               ('ONE_POINT', "One Point", "One-point perspective"),
               ('TWO_POINT', "Two Point", "Two-point perspective"),
               ('THREE_POINT', "Three Point", "Three-point perspective"),
               ('FISH_EYE', "Fish Eye", "Fisheye (spherical) perspective cage")],
        default='NONE', update=switch_perspective_type_prop
    )
    camera_eye_height: FloatProperty(name="Camera Eye Height", default=1.6, min=0.1)
    camera_distance: FloatProperty(name="Camera Distance from Target", default=15.0, min=1.0)

    # --- Grid Creation Properties (New) ---
    grid_active_plane: EnumProperty(
        name="Active Grid Plane",
        items=[('FRONT', "Front (YZ)", "Create grid on the YZ plane"),
               ('BACK', "Back (YZ)", "Create grid on the YZ plane (offset for back)"),
               ('TOP', "Top (XY)", "Create grid on the XY plane"),
               ('BOTTOM', "Bottom (XY)", "Create grid on the XY plane (offset for bottom)"),
               ('LEFT', "Left (XZ)", "Create grid on the XZ plane (offset for left)"),
               ('RIGHT', "Right (XZ)", "Create grid on the XZ plane")],
        default='FRONT'
    )
    grid_center: FloatVectorProperty(name="Grid Box Center", size=3, default=(0,0,0))
    grid_size: FloatVectorProperty(name="Grid Box Size (X,Y,Z)", size=3, default=(10,10,10), min=0.1)
    grid_subdivisions_u: IntProperty(name="Subdivisions U", default=10, min=1)
    grid_subdivisions_v: IntProperty(name="Subdivisions V", default=10, min=1)
    grid_draw_front: BoolProperty(name="Draw Front Grid", default=True)
    grid_draw_back: BoolProperty(name="Draw Back Grid", default=False)
    grid_draw_top: BoolProperty(name="Draw Top Grid", default=True)
    grid_draw_bottom: BoolProperty(name="Draw Bottom Grid", default=False)
    grid_draw_left: BoolProperty(name="Draw Left Grid", default=False)
    grid_draw_right: BoolProperty(name="Draw Right Grid", default=False)

    # --- Guide Visibility (New - simple version for now) ---
    # This could be expanded to a CollectionProperty for more robust state tracking
    # For now, operators will just toggle. UI can show buttons for main groups.

    # --- Line Trimming Properties (New) ---
    trim_margin: FloatProperty(name="Trim Margin (0-1)", default=0.05, min=0.0, max=0.5, description="Margin outside camera view for trimming (0=exact edge)")

    trim_view_margin: FloatProperty(
        name="View Margin",
        description="Margin from camera view edges (0.0 to 0.49). Lines inside this margin are always kept.",
        default=0.05,  # Slightly inside the camera border
        min=0.0, max=0.49, subtype='FACTOR'
    )
    trim_keep_near_border_distance: FloatProperty(
        name="Keep Near Border",
        description="Normalized distance outside the camera border to keep and trim lines (0.0 = only inside, 0.1 = keep lines just outside border).",
        default=0.1, min=0.0, max=0.5, subtype='FACTOR'
    )
    trim_min_visible_segment_length: FloatProperty(
        name="Min Segment Length",
        description="Minimum world-space length for a trimmed line segment to be kept.",
        default=0.05, min=0.001, max=200.0
    )
    trim_delete_lines_outside_strict_view: BoolProperty(
        name="Delete Only Far Lines",
        description="If true, only lines far from the camera view are deleted. Lines near the border are kept.",
        default=False
    )
    trim_deletion_distance_threshold: FloatProperty(
        name="Deletion Distance Threshold",
        description="Normalized distance outside the camera view to delete lines (used only if 'Delete Only Far Lines' is true).",
        default=0.2, min=0.0, max=2.0
    )
    trim_start_percent: FloatProperty(
        name="Start % Inside",
        description="Where to start the trimmed line as a percentage of the visible segment (0 = at border, 0.2 = 20% into view)",
        default=0.0, min=0.0, max=0.9, subtype='FACTOR'
    )
    trim_end_percent: FloatProperty(
        name="End % Inside",
        description="Where to end the trimmed line as a percentage of the visible segment (1 = at far border, 0.8 = 80% into view)",
        default=1.0, min=0.1, max=1.0, subtype='FACTOR'
    )
# -----------------------------------------------------------
# Helper: Add Vanishing Point Empty if Missing
# -----------------------------------------------------------
def add_vp_empty_if_missing(context, target_vp_name, default_location, empty_color=(0.8, 0.8, 0.8, 1.0)): # Removed type_key_for_1p_z_snap
    vp_obj = bpy.data.objects.get(target_vp_name)
    if not vp_obj:
        helpers_coll = get_helpers_collection(context)
        vp_obj = bpy.data.objects.new(target_vp_name, None)
        helpers_coll.objects.link(vp_obj)
        vp_obj.empty_display_type = 'SPHERE'
        vp_obj.empty_display_size = 0.35
        vp_obj.location = default_location
        vp_obj.color = empty_color[:4] # Ensure it's RGBA
        # No automatic Z snapping for ONE_POINT mode based on previous fix
        return vp_obj
    else:
        # If VP exists, preserve its location unless default_location is explicitly different
        # For this function's purpose, if it exists, we generally want to preserve its location.
        # However, the calling functions (create_default_... ) handle location logic.
        # We'll update color here if needed.
        vp_obj.color = empty_color[:4]
        return vp_obj


# -----------------------------------------------------------
# Operators
# -----------------------------------------------------------

# ... (Keep all your existing code before the operators, including bl_info, utility functions, properties, etc.) ...

# MAKE SURE 'get_guides_collection' and HORIZON_CURVE_OBJ_NAME are defined before this point.


class PERSPECTIVE_OT_extract_perspective_from_image(bpy.types.Operator):
    """Extract one-point perspective from a Grease Pencil drawing on a reference image.
    Requires at least two strokes drawn on the active GPencil object's active frame.
    The intersection of the first two strokes is used to compute the vanishing point.
    Tip: Ensure you have at least two strokes and that a Grease Pencil object is active."""
    bl_idname = "perspective_splines.extract_perspective_from_image"
    bl_label = "Extract Perspective from Image (GPencil)"
    bl_description = ("Select a Grease Pencil object that has at least two strokes on its active frame. "
                      "The intersection of the first two strokes defines the one-point vanishing point.")
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        ts = context.scene.perspective_tool_settings_splines
        if ts.current_perspective_type != 'ONE_POINT':
            self.report({'ERROR'}, "This extraction currently only supports ONE POINT mode.")
            return {'CANCELLED'}

        gp_obj = context.active_object
        # Fallback: If the active object is not a GPencil, try to find one in the scene.
        if not gp_obj or gp_obj.type != 'GPENCIL':
            self.report({'WARNING'}, "Active object is not a GPencil. Searching scene for a Grease Pencil object...")
            gp_obj = next((obj for obj in context.scene.objects if obj.type == 'GPENCIL'), None)

        if not gp_obj:
            self.report({'ERROR'}, "No active Grease Pencil object found. Please add a GPencil object with strokes on your reference image.")
            return {'CANCELLED'}

        gp_data = gp_obj.data
        if not gp_data.layers:
            self.report({'ERROR'}, "No GPencil layers found.")
            return {'CANCELLED'}
        layer = gp_data.layers.active or gp_data.layers[0]
        if not layer.frames:
            self.report({'ERROR'}, "No GPencil frames available in the active layer.")
            return {'CANCELLED'}
        frame = layer.frames.active if layer.frames.active else layer.frames[0]
        strokes = frame.strokes
        if len(strokes) < 2:
            self.report({'ERROR'}, "At least two strokes are required for one-point perspective extraction. Please draw at least one more stroke.")
            return {'CANCELLED'}

        def get_stroke_line(stroke):
            if len(stroke.points) < 2:
                return None
            p0 = Vector((stroke.points[0].co.x, stroke.points[0].co.y))
            p1 = Vector((stroke.points[-1].co.x, stroke.points[-1].co.y))
            return p0, p1

        line1 = get_stroke_line(strokes[0])
        line2 = get_stroke_line(strokes[1])
        if not line1 or not line2:
            self.report({'ERROR'}, "Could not extract two valid lines from the strokes.")
            return {'CANCELLED'}

        def line_intersection(p0, p1, q0, q1):
            s = p1 - p0
            r = q1 - q0
            denom = s.x * r.y - s.y * r.x
            if abs(denom) < 1e-6:
                return None  # Lines are parallel.
            t = ((q0 - p0).x * r.y - (q0 - p0).y * r.x) / denom
            return p0 + t * s

        ip = line_intersection(line1[0], line1[1], line2[0], line2[1])
        if ip is None:
            self.report({'ERROR'}, "The strokes did not intersect.")
            return {'CANCELLED'}

        # Use the scene's current horizon Z value for the 3D vanishing point.
        horizon_z = ts.horizon_y_level
        vp_location = Vector((ip.x, ip.y, horizon_z))

        vp_name = VP_TYPE_SPECIFIC_PREFIX_MAP['ONE_POINT'] + "_1"
        vp_obj = bpy.data.objects.get(vp_name)
        if not vp_obj:
            vp_obj = add_vp_empty_if_missing(context, vp_name, vp_location, ts.one_point_vp_empty_color)
        else:
            vp_obj.location = vp_location

        update_dynamic_horizon_line_curve(context)
        self.report({'INFO'}, f"Extracted 1P perspective: vanishing point set to {vp_location}")
        return {'FINISHED'}





class PERSPECTIVE_OT_clip_guides_to_camera(bpy.types.Operator):
    """Clips each perspective guide so that its endpoints lie exactly on the camera borders."""
    bl_idname = "perspective_splines.clip_guides_to_camera"
    bl_label = "Clip Guides to Camera Borders"
    bl_options = {'REGISTER', 'UNDO'}

    def liang_barsky_clip(self, A, B):
        """
        Liang–Barsky clipping in 2D.
        A and B are 2D tuples representing the projected endpoints (x,y) in normalized camera space.
        Returns (t_min, t_max) such that:
          clipped_point = A + t*(B-A) for t in [t_min, t_max].
        If the line does not cross the unit square, returns None.
        """
        dx = B[0] - A[0]
        dy = B[1] - A[1]
        t_min = 0.0
        t_max = 1.0

        p = [-dx, dx, -dy, dy]
        q = [A[0], 1 - A[0], A[1], 1 - A[1]]

        for i in range(4):
            if p[i] == 0:
                if q[i] < 0:
                    return None  # Parallel and outside
            else:
                r = q[i] / p[i]
                if p[i] < 0:
                    t_min = max(t_min, r)
                else:
                    t_max = min(t_max, r)
                if t_min > t_max:
                    return None  # No intersection
        return t_min, t_max

    def execute(self, context):
        scene = context.scene
        cam = scene.camera
        if not cam:
            self.report({'WARNING'}, "No active camera detected.")
            return {'CANCELLED'}
        
        # Get guides collection (assumes you have a helper function get_guides_collection)
        guides_coll = get_guides_collection(context)
        if not guides_coll:
            self.report({'WARNING'}, "No guides collection found.")
            return {'CANCELLED'}

        trimmed_obj_count = 0

        # Loop over all guide objects in your guides collection (skip the horizon line)
        for obj in guides_coll.objects:
            if obj.type != 'CURVE' or obj.name == "VISUAL_Horizon_Line":
                continue

            curve = obj.data
            change_flag = False
            # Loop over every spline in the curve (assuming your guides are POLY curves with at least 2 points)
            for spline in curve.splines:
                if spline.type != 'POLY' or len(spline.points) < 2:
                    continue

                # Get the endpoints in world space
                pt0_world = obj.matrix_world @ Vector(spline.points[0].co[:3])
                pt1_world = obj.matrix_world @ Vector(spline.points[-1].co[:3])
                
                # Project endpoints to normalized camera space (NDC)
                A_ndc = world_to_camera_view(scene, cam, pt0_world)
                B_ndc = world_to_camera_view(scene, cam, pt1_world)
                
                # Only use the x and y components for 2D clipping
                clip_result = self.liang_barsky_clip((A_ndc.x, A_ndc.y), (B_ndc.x, B_ndc.y))
                if clip_result is None:
                    # If the guide does not cross through the view, you may choose to hide it or set its endpoints to a dummy value.
                    # Here we set both endpoints to the same 0-vector in local space to effectively collapse the guide.
                    spline.points[0].co = (0, 0, 0, 1)
                    spline.points[-1].co = (0, 0, 0, 1)
                    change_flag = True
                else:
                    t_min, t_max = clip_result
                    # Find the new world positions via linear interpolation
                    new_pt0_world = pt0_world + (pt1_world - pt0_world) * t_min
                    new_pt1_world = pt0_world + (pt1_world - pt0_world) * t_max

                    # Convert these world positions back to the object's local space
                    inv_world = obj.matrix_world.inverted()
                    new_pt0_local = inv_world @ new_pt0_world
                    new_pt1_local = inv_world @ new_pt1_world

                    spline.points[0].co = (new_pt0_local.x, new_pt0_local.y, new_pt0_local.z, 1)
                    spline.points[-1].co = (new_pt1_local.x, new_pt1_local.y, new_pt1_local.z, 1)
                    change_flag = True

            if change_flag:
                curve.update_tag()
                trimmed_obj_count += 1

        self.report({'INFO'}, f"Clipped guides in {trimmed_obj_count} object(s).")
        return {'FINISHED'}


class PERSPECTIVE_OT_clear_grid_planes(Operator):
    bl_idname = "perspective_splines.clear_grid_planes"
    bl_label = "Clear Only Grid Planes"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        count = clear_guides_with_prefix(context, ["GridPlane_"])
        self.report({'INFO'}, f"Cleared {count} grid plane objects." if count > 0 else "No grid planes to clear.")
        return {'FINISHED'}
    

class PERSPECTIVE_OT_toggle_guide_visibility(Operator):
    bl_idname = "perspective_splines.toggle_guide_visibility"
    bl_label = "Toggle Guide Group Visibility"
    bl_options = {'REGISTER', 'UNDO'}

    group_prefix: StringProperty(name="Guide Group Prefix")
    # Optional: target_visibility: BoolProperty(name="Target Visibility") # To explicitly set, not just toggle

    def execute(self, context):
        if not self.group_prefix:
            self.report({'WARNING'}, "No guide group prefix specified.")
            return {'CANCELLED'}

        guides_coll = get_guides_collection(context)
        if not guides_coll:
            self.report({'INFO'}, "Guides collection not found.")
            return {'CANCELLED'}

        found_any = False
        # Determine new visibility state: if any are visible, hide all; else show all
        # This is a simple toggle logic. More advanced would use stored states.
        currently_any_visible = False
        for obj in guides_coll.objects:
            if obj.name.startswith(self.group_prefix) and not obj.hide_viewport:
                currently_any_visible = True
                break
        
        new_hide_state = currently_any_visible # If any are visible, new state is to hide them

        for obj in guides_coll.objects:
            if obj.type == 'CURVE' and obj.name.startswith(self.group_prefix):
                obj.hide_viewport = new_hide_state
                found_any = True
        
        if not found_any:
            self.report({'INFO'}, f"No guides found with prefix '{self.group_prefix}'.")
        else:
            action = "Hid" if new_hide_state else "Shown"
            self.report({'INFO'}, f"{action} guides for group '{self.group_prefix}'.")
        
        return {'FINISHED'}

class PERSPECTIVE_OT_create_box_grid(Operator):
    bl_idname = "perspective_splines.create_box_grid"
    bl_label = "Create Perspective Box Grid"
    bl_options = {'REGISTER', 'UNDO'}

    def create_plane_grid(self, context, center, size_u, size_v, subs_u, subs_v,
                          u_axis_vec, v_axis_vec, normal_vec,
                          plane_name_suffix, guides_coll, ts):
        """ Helper to create a single grid plane """
        all_spline_data = []
        half_size_u = size_u / 2.0
        half_size_v = size_v / 2.0

        # Lines along V direction (varying U)
        for i in range(subs_u + 1):
            t = (i / subs_u) - 0.5 # from -0.5 to 0.5
            p_offset = u_axis_vec * (t * size_u)
            pt1 = center + p_offset - (v_axis_vec * half_size_v)
            pt2 = center + p_offset + (v_axis_vec * half_size_v)
            all_spline_data.append([pt1, pt2])

        # Lines along U direction (varying V)
        for i in range(subs_v + 1):
            t = (i / subs_v) - 0.5 # from -0.5 to 0.5
            p_offset = v_axis_vec * (t * size_v)
            pt1 = center + p_offset - (u_axis_vec * half_size_u)
            pt2 = center + p_offset + (u_axis_vec * half_size_u)
            all_spline_data.append([pt1, pt2])
        
        if all_spline_data:
            # Create one object per plane grid for easier management
            grid_obj_name = f"GridPlane_{plane_name_suffix}"
            # Ensure unique name
            idx = 1
            temp_name = grid_obj_name
            while temp_name in bpy.data.objects:
                temp_name = f"{grid_obj_name}.{str(idx).zfill(3)}"
                idx +=1
            grid_obj_name = temp_name

            create_curve_object(context, grid_obj_name, all_spline_data, guides_coll,
                                ts.guide_curves_thickness, ts.guide_curves_opacity)
            return True
        return False

    def execute(self, context):
        ts = context.scene.perspective_tool_settings_splines
        guides_coll = get_guides_collection(context)
        clear_guides_with_prefix(context, ["GridPlane_"]) # Clear old grids

        center = Vector(ts.grid_center)
        size = Vector(ts.grid_size)
        subs_u = ts.grid_subdivisions_u
        subs_v = ts.grid_subdivisions_v # Using U for lines along one axis, V for lines along the other for each plane.

        created_any = False

        # Front (+Y) / Back (-Y) : YZ plane, U is Z, V is X
        if ts.grid_draw_front:
            plane_center = center + Vector((0, size.y / 2.0, 0))
            if self.create_plane_grid(context, plane_center, size.z, size.x, subs_v, subs_u, 
                                 Vector((0,0,1)), Vector((1,0,0)), Vector((0,1,0)), "Front", guides_coll, ts):
                created_any = True
        if ts.grid_draw_back:
            plane_center = center - Vector((0, size.y / 2.0, 0))
            if self.create_plane_grid(context, plane_center, size.z, size.x, subs_v, subs_u, 
                                 Vector((0,0,1)), Vector((1,0,0)), Vector((0,-1,0)), "Back", guides_coll, ts):
                created_any = True
        
        # Top (+Z) / Bottom (-Z) : XY plane, U is X, V is Y
        if ts.grid_draw_top:
            plane_center = center + Vector((0,0, size.z / 2.0))
            if self.create_plane_grid(context, plane_center, size.x, size.y, subs_u, subs_v,
                                 Vector((1,0,0)), Vector((0,1,0)), Vector((0,0,1)), "Top", guides_coll, ts):
                created_any = True
        if ts.grid_draw_bottom:
            plane_center = center - Vector((0,0, size.z / 2.0))
            if self.create_plane_grid(context, plane_center, size.x, size.y, subs_u, subs_v,
                                 Vector((1,0,0)), Vector((0,1,0)), Vector((0,0,-1)), "Bottom", guides_coll, ts):
                created_any = True

        # Right (+X) / Left (-X) : XZ plane (careful, Blender's XZ is often Y up), let's say YZ plane, U is Y, V is Z
        # For side views, let's use YZ plane where U is Y, V is Z.
        if ts.grid_draw_right: # +X side
            plane_center = center + Vector((size.x / 2.0, 0, 0))
            if self.create_plane_grid(context, plane_center, size.y, size.z, subs_u, subs_v, # U along Y, V along Z
                                 Vector((0,1,0)), Vector((0,0,1)), Vector((1,0,0)), "Right", guides_coll, ts):
                 created_any = True
        if ts.grid_draw_left: # -X side
            plane_center = center - Vector((size.x / 2.0, 0, 0))
            if self.create_plane_grid(context, plane_center, size.y, size.z, subs_u, subs_v,
                                 Vector((0,1,0)), Vector((0,0,1)), Vector((-1,0,0)), "Left", guides_coll, ts):
                created_any = True

        if created_any:
            self.report({'INFO'}, "Generated grid plane(s).")
        else:
            self.report({'INFO'}, "No grid planes selected for drawing.")
        return {'FINISHED'}    

class PERSPECTIVE_OT_merge_specific_guides(Operator):
    bl_idname = "perspective_splines.merge_specific_guides"
    bl_label = "Merge Specific Perspective Guides"
    bl_options = {'REGISTER', 'UNDO'}

    group_identifier: StringProperty(
        name="Guide Group Identifier",
        description="Identifier for the group of guides to merge (e.g., 2P_VP1, ALL_CURRENT_TYPE)",
        default="ALL_SCENE_GUIDES_FALLBACK" # Default to merging all if no specific group given
    )

    # This dictionary maps a 'group_identifier' to:
    # 1. A tuple of prefixes to identify the curves for that group.
    # 2. A suggested suffix for the merged object's name.
    # This will be populated dynamically or used with perspective-type specific sub-mappings.
    
    # Structure: PERSPECTIVE_TYPE_KEY: { GROUP_NAME_FOR_UI: ( (PREFIX1, PREFIX2, ...), "MergedNameSuffix" ) }
    GUIDE_GROUP_DEFS = {
        'ONE_POINT': {
            'MAIN_LINES': (("1P_Guides",), "1P_Lines")
        },
        'TWO_POINT': {
            'VP1_LINES': (("2P_Guides_VP1",), "2P_VP1_Lines"),
            'VP2_LINES': (("2P_Guides_VP2",), "2P_VP2_Lines"),
            'VERTICAL_LINES': (("2P_Guides_Vertical",), "2P_Vertical_Lines")
        },
        'THREE_POINT': {
            'H1_LINES': (("3P_Guides_H1",), "3P_H1_Lines"),
            'H2_LINES': (("3P_Guides_H2",), "3P_H2_Lines"),
            'V_LINES': (("3P_Guides_V",), "3P_V_Lines")
        },
        'FISH_EYE': {
            # FE guides might be FE_Guides_Lon_X or FE_Guides_Lat_X or just FE_Guides_X
            'LONGITUDE_LINES': (("FE_Guides_Lon",), "FE_Longitude_Lines"), # Specific if you named them like this
            'LATITUDE_LINES': (("FE_Guides_Lat",), "FE_Latitude_Lines"),   # Specific if you named them like this
            'ALL_FE_LINES': (("FE_Guides",), "FE_All_Lines") # General prefix for all FE guides
        }
    }


    @classmethod
    def poll(cls, context):
        guides_coll = get_guides_collection(context)
        return guides_coll and any(o.type == 'CURVE' and o.name != HORIZON_CURVE_OBJ_NAME for o in guides_coll.objects)

    def get_curves_for_group(self, context, guides_coll):
        tool_settings = context.scene.perspective_tool_settings_splines
        current_perspective_type = tool_settings.current_perspective_type
        
        curves_to_process = []
        target_prefixes = []
        merged_name_suffix = "Guides" # Default suffix

        if self.group_identifier == "ALL_SCENE_GUIDES_FALLBACK":
            # Collect all known guide prefixes regardless of type for a true "merge all"
            all_known_prefixes = set()
            for type_key, groups in self.GUIDE_GROUP_DEFS.items():
                for group_key, (prefixes, _) in groups.items():
                    all_known_prefixes.update(prefixes)
            if not all_known_prefixes: # Fallback if GUIDE_GROUP_DEFS is empty somehow
                 all_known_prefixes = ("1P_Guides", "2P_Guides_", "3P_Guides_", "FE_Guides_")

            target_prefixes = tuple(all_known_prefixes)
            merged_name_suffix = "All_Scene_Guides"

        elif self.group_identifier == "ALL_CURRENT_TYPE":
            if current_perspective_type != 'NONE' and current_perspective_type in self.GUIDE_GROUP_DEFS:
                current_type_defs = self.GUIDE_GROUP_DEFS[current_perspective_type]
                all_type_prefixes = set()
                for _, (prefixes, _) in current_type_defs.items():
                    all_type_prefixes.update(prefixes)
                target_prefixes = tuple(all_type_prefixes)
                merged_name_suffix = f"{current_perspective_type.replace('_','')}All_Guides"
            else: # No specific type or no defs for it
                return [], "Guides_NoType"

        else: # Specific group for the current type (e.g., "2P_VP1_LINES")
            if current_perspective_type != 'NONE' and current_perspective_type in self.GUIDE_GROUP_DEFS:
                current_type_defs = self.GUIDE_GROUP_DEFS[current_perspective_type]
                # The group_identifier should directly match a key in current_type_defs
                # e.g. group_identifier = "VP1_LINES" for perspective_type 'TWO_POINT'
                if self.group_identifier in current_type_defs:
                    prefixes_tuple, suffix_from_def = current_type_defs[self.group_identifier]
                    target_prefixes = prefixes_tuple
                    merged_name_suffix = suffix_from_def
                else: # Identifier not found for current type
                    return [], f"UnknownGroup_{self.group_identifier}"
            else: # No type selected for specific group
                return [], f"Guides_NoType_For_{self.group_identifier}"

        if not target_prefixes:
            return [], "NoPrefixes"

        for obj in guides_coll.objects:
            if obj.type == 'CURVE' and obj.name != HORIZON_CURVE_OBJ_NAME:
                for prefix in target_prefixes:
                    if obj.name.startswith(prefix):
                        curves_to_process.append(obj)
                        break # Object matched, move to next object
        
        return curves_to_process, merged_name_suffix


    def execute(self, context):
        guides_coll = get_guides_collection(context)
        if not guides_coll:
            self.report({'INFO'}, "Guides collection not found.")
            return {'CANCELLED'}

        curves_to_merge, base_name_suffix = self.get_curves_for_group(context, guides_coll)

        if not curves_to_merge:
            self.report({'INFO'}, f"No guide curves found for group identifier: '{self.group_identifier}'.")
            return {'CANCELLED'}

        if len(curves_to_merge) < 2:
            self.report({'INFO'}, f"Only {len(curves_to_merge)} curve(s) found for '{self.group_identifier}'. No merge needed or possible.")
            if curves_to_merge: # If one, select it
                bpy.ops.object.select_all(action='DESELECT')
                try:
                    curves_to_merge[0].select_set(True)
                    context.view_layer.objects.active = curves_to_merge[0]
                except ReferenceError:
                    self.report({'WARNING'}, "The single curve found no longer exists.")
                    return {'CANCELLED'}
            return {'FINISHED'}

        if context.mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
        
        original_active = context.view_layer.objects.active
        original_selection = list(context.selected_objects) # Make a copy
        
        bpy.ops.object.select_all(action='DESELECT')
        valid_curves_for_join = []
        for obj in curves_to_merge:
            if obj.name in bpy.data.objects: # Check if object still exists
                obj.select_set(True)
                valid_curves_for_join.append(obj)
            else:
                print(f"Info: Object '{obj.name}' for merge group '{self.group_identifier}' no longer exists.")
        
        if len(valid_curves_for_join) < 2:
            self.report({'INFO'}, f"Not enough valid curves ({len(valid_curves_for_join)}) remaining to merge for '{self.group_identifier}'.")
            # Restore original selection
            bpy.ops.object.select_all(action='DESELECT')
            for obj_sel in original_selection:
                if obj_sel and obj_sel.name in bpy.data.objects:
                    try: obj_sel.select_set(True)
                    except ReferenceError: pass
            if original_active and original_active.name in bpy.data.objects:
                try: context.view_layer.objects.active = original_active
                except ReferenceError: pass
            return {'CANCELLED'}
            
        context.view_layer.objects.active = valid_curves_for_join[0]

        try:
            bpy.ops.object.join()
        except RuntimeError as e:
            self.report({'ERROR'}, f"Merge failed for group '{self.group_identifier}': {e}")
            # Restore original selection attempt
            bpy.ops.object.select_all(action='DESELECT')
            for obj_sel in original_selection:
                if obj_sel and obj_sel.name in bpy.data.objects:
                   try: obj_sel.select_set(True)
                   except ReferenceError: pass
            if original_active and original_active.name in bpy.data.objects:
                try: context.view_layer.objects.active = original_active
                except ReferenceError: pass
            return {'CANCELLED'}
        
        merged_obj = context.active_object
        if merged_obj:
            # Create a unique name for the merged object
            final_name_base = f"Merged_{base_name_suffix}"
            current_name_to_check = final_name_base
            idx = 1
            while current_name_to_check in bpy.data.objects and bpy.data.objects[current_name_to_check] != merged_obj:
                current_name_to_check = f"{final_name_base}.{str(idx).zfill(3)}"
                idx += 1
            merged_obj.name = current_name_to_check
            self.report({'INFO'}, f"Merged {len(valid_curves_for_join)} guides for '{self.group_identifier}' into: {merged_obj.name}")
        else:
            self.report({'WARNING'}, "Merge did not result in an active object.")
            # Restore selection might be complex here if join partly failed.
            return {'CANCELLED'}

        return {'FINISHED'}


# --- Keep your existing PERSPECTIVE_OT_merge_guides if you want a simple "Merge All in Collection" button ---
# OR remove it if PERSPECTIVE_OT_merge_specific_guides with "ALL_SCENE_GUIDES_FALLBACK" covers its need.
# For now, let's assume you might want to keep it as a distinct "merge all visible guides".

class PERSPECTIVE_OT_merge_guides(Operator): # This is your existing "Merge Guides Only"
    bl_idname = "perspective_splines.merge_guides"
    bl_label = "Merge All Visible Guides" # Renamed label for clarity if keeping both merge ops
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        guides_coll = get_guides_collection(context)
        curves_to_merge = [
            o for o in guides_coll.objects 
            if o.type == 'CURVE' and o.data and o.data.splines and o.name != HORIZON_CURVE_OBJ_NAME
        ]
        if not curves_to_merge:
            self.report({'INFO'}, "No guide curves found to merge.")
            return {'CANCELLED'}
        
        if len(curves_to_merge) < 2:
            self.report({'INFO'}, "Only one guide curve present. No merge needed.")
            if curves_to_merge: # Select the single curve
                bpy.ops.object.select_all(action='DESELECT')
                try:
                    curves_to_merge[0].select_set(True)
                    context.view_layer.objects.active = curves_to_merge[0]
                except ReferenceError: pass
            return {'FINISHED'} # Or CANCELLED

        if context.mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
        
        original_active = context.view_layer.objects.active
        original_selection = list(context.selected_objects) 
        bpy.ops.object.select_all(action='DESELECT')
        
        valid_curves_for_join = []
        for obj in curves_to_merge:
            if obj.name in bpy.data.objects:
                obj.select_set(True)
                valid_curves_for_join.append(obj)
        
        if len(valid_curves_for_join) < 2:
            self.report({'INFO'}, "Not enough valid curves remaining to merge.")
            # Restore original selection
            # ... (similar restoration as in merge_specific_guides) ...
            return {'CANCELLED'}
            
        context.view_layer.objects.active = valid_curves_for_join[0]

        try:
            bpy.ops.object.join()
        except RuntimeError as e:
            self.report({'ERROR'}, f"Merge all guides failed: {e}")
            # ... (similar restoration) ...
            return {'CANCELLED'}
        
        merged_obj = context.active_object
        if merged_obj:
            base_name = "Merged_All_Guides"
            current_name_to_check = base_name
            idx = 1
            while current_name_to_check in bpy.data.objects and bpy.data.objects[current_name_to_check] != merged_obj:
                current_name_to_check = f"{base_name}.{str(idx).zfill(3)}"
                idx += 1
            merged_obj.name = current_name_to_check
            self.report({'INFO'}, f"Merged all guides into object: {merged_obj.name}")
        else:
            self.report({'WARNING'}, "Merge all operation did not result in an active object.")
            return {'CANCELLED'}
        return {'FINISHED'}


class PERSPECTIVE_OT_merge_guides(Operator):
    bl_idname = "perspective_splines.merge_guides"
    bl_label = "Merge Guides Only"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        guides_coll = get_guides_collection(context)
        # Select all curve objects in the guides collection (except the horizon curve)
        curves_to_merge = [o for o in guides_coll.objects 
                           if o.type == 'CURVE' and o.data and o.data.splines and o.name != HORIZON_CURVE_OBJ_NAME]
        if not curves_to_merge:
            self.report({'INFO'}, "No guide curves found to merge.")
            return {'CANCELLED'}
        
        # Ensure we are in Object mode
        if context.mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
        
        original_active = context.view_layer.objects.active
        original_selection = list(context.selected_objects) # Make a copy
        bpy.ops.object.select_all(action='DESELECT')
        
        for obj in curves_to_merge:
            obj.select_set(True)
        
        if not curves_to_merge: # Should be caught earlier, but as a safeguard
            bpy.ops.object.select_all(action='DESELECT') # Restore selection
            for obj in original_selection:
                if obj and obj.name in bpy.data.objects: # Check if obj still exists
                   try: obj.select_set(True)
                   except ReferenceError: pass
            context.view_layer.objects.active = original_active
            self.report({'ERROR'}, "No curves were selected for merging.")
            return {'CANCELLED'}
            
        context.view_layer.objects.active = curves_to_merge[0]

        try:
            bpy.ops.object.join()
        except RuntimeError as e:
            self.report({'ERROR'}, f"Merge failed: {e}")
            # Restore selection before returning
            bpy.ops.object.select_all(action='DESELECT')
            for obj in original_selection:
                if obj and obj.name in bpy.data.objects:
                   try: obj.select_set(True)
                   except ReferenceError: pass
            context.view_layer.objects.active = original_active
            return {'CANCELLED'}
        
        merged_obj = context.active_object
        if merged_obj:
            self.report({'INFO'}, f"Merged guides into object: {merged_obj.name}")
        else:
            self.report({'WARNING'}, "Merge operation did not result in an active object.")
            # Attempt to restore selection
            bpy.ops.object.select_all(action='DESELECT')
            for obj in original_selection:
                if obj and obj.name in bpy.data.objects:
                   try: obj.select_set(True)
                   except ReferenceError: pass
            context.view_layer.objects.active = original_active
            return {'CANCELLED'}


        # Restore original selection (optional, but good practice if they weren't part of the merge)
        # For this operator, the merged object becomes the new selection.
        # If you want to restore the previous broader selection, uncomment:
        # bpy.ops.object.select_all(action='DESELECT')
        # for obj in original_selection:
        #     if obj and obj.name in bpy.data.objects and obj.name != merged_obj.name:
        #         try: obj.select_set(True)
        #         except ReferenceError: pass
        # if merged_obj and merged_obj.name in bpy.data.objects: # Ensure merged object remains selected
        #    merged_obj.select_set(True)
        #    context.view_layer.objects.active = merged_obj
        # else:
        #    context.view_layer.objects.active = original_active

        return {'FINISHED'}



# ... (Rest of your operators: PERSPECTIVE_OT_generate_horizon_spline, etc. down to PERSPECTIVE_OT_convert_to_grease_pencil)

class PERSPECTIVE_OT_generate_horizon_spline(Operator):
    bl_idname = "perspective_splines.generate_horizon"
    bl_label = "Create/Set Horizon Ctrl & Visual"
    bl_options = {'REGISTER', 'UNDO'}
    def execute(self, context):
        tool_settings = context.scene.perspective_tool_settings_splines
        helpers_coll = get_helpers_collection(context)
        horizon_ctrl = get_horizon_control_object()
        if not horizon_ctrl:
            horizon_ctrl = bpy.data.objects.new(HORIZON_CTRL_OBJ_NAME, None)
            helpers_coll.objects.link(horizon_ctrl)
            horizon_ctrl.empty_display_type = 'CIRCLE'
            horizon_ctrl.empty_display_size = 0.5
        horizon_ctrl.location = Vector((0, 0, tool_settings.horizon_y_level))

        horizon_curve_obj = get_horizon_curve_object()
        if not horizon_curve_obj:
            guides_coll = get_guides_collection(context)
            hz_len = tool_settings.horizon_line_length / 2.0
            # Points for the horizon curve visual should be relative to its object origin (0,0,0)
            # The update_dynamic_horizon_line_curve function handles setting world space coords.
            # For initial creation, we can use simple points, they will be updated.
            pts = [Vector((-hz_len, 0, 0)), Vector((hz_len, 0, 0))]
            col = list(tool_settings.horizon_line_color) # Get the RGBA color from settings
            horizon_curve_obj = create_curve_object(context, HORIZON_CURVE_OBJ_NAME, [pts], guides_coll,
                                        bevel_depth=tool_settings.horizon_line_thickness,
                                        opacity=col[3], color_rgb=col[:3]) # Pass opacity and color_rgb separately
            if not horizon_curve_obj:
                self.report({'ERROR'}, "Failed to create horizon visual line.")
                return {'CANCELLED'}
            # Position the curve object itself at the horizon Z, though update_dynamic... might override
            # horizon_curve_obj.location.z = tool_settings.horizon_y_level 
            # Actually, update_dynamic_horizon_line_curve expects it at world origin if it's placing VPs directly.
            # For 1P, it effectively re-centers it. So (0,0,0) is fine.

        update_dynamic_horizon_line_curve(context) # This will correctly position/shape it
        self.report({'INFO'}, f"Horizon elements set. Ctrl Z: {tool_settings.horizon_y_level:.2f}")
        return {'FINISHED'}

class PERSPECTIVE_OT_add_vanishing_point_empty(Operator):
    bl_idname = "perspective_splines.add_vp_empty"
    bl_label = "Add Generic VP Empty"
    bl_options = {'REGISTER', 'UNDO'}
    def execute(self, context):
        tool_settings = context.scene.perspective_tool_settings_splines
        prefix = VP_PREFIX + "Custom" # Default for generic
        if tool_settings.current_perspective_type in VP_TYPE_SPECIFIC_PREFIX_MAP:
            prefix = VP_TYPE_SPECIFIC_PREFIX_MAP[tool_settings.current_perspective_type]

        num = 1
        while f"{prefix}_Generic_{num}" in bpy.data.objects: num += 1
        vp_name = f"{prefix}_Generic_{num}"
        vp_obj = add_vp_empty_if_missing(context, vp_name, context.scene.cursor.location.copy(), empty_color=(0.7,0.7,0.7,1.0)) # Pass empty_color
        vp_obj.empty_display_type = 'CUBE' # Differentiate generic
        self.report({'INFO'}, f"Added generic VP: {vp_name}")
        try:
            update_dynamic_horizon_line_curve(context)
            update_vp_empty_colors(tool_settings, context)
        except Exception as e: print(f"Error in updates post add_vp_empty: {e}")
        return {'FINISHED'}

class PERSPECTIVE_OT_remove_selected_helper_empty(Operator):
    bl_idname = "perspective_splines.remove_selected_helper_empty"
    bl_label = "Remove Selected Helper"
    bl_options = {'REGISTER', 'UNDO'}
    @classmethod
    def poll(cls, context):
        act_obj = context.active_object
        return act_obj and act_obj.type == 'EMPTY' and \
               (act_obj.name.startswith(VP_PREFIX) or act_obj.name == HORIZON_CTRL_OBJ_NAME)
    def execute(self, context):
        obj_to_remove = context.active_object
        name = obj_to_remove.name
        is_hz_ctrl = (name == HORIZON_CTRL_OBJ_NAME)
        try: bpy.data.objects.remove(obj_to_remove, do_unlink=True)
        except: pass # Ignore if already gone
        if is_hz_ctrl:
            try: bpy.ops.perspective_splines.clear_horizon('EXEC_DEFAULT')
            except Exception as e: print(f"Error clearing horizon after ctrl removal: {e}")
        try: update_dynamic_horizon_line_curve(context)
        except Exception as e: print(f"Error updating horizon after helper removal: {e}")
        self.report({'INFO'}, f"Removed helper: {name}.")
        return {'FINISHED'}

class PERSPECTIVE_OT_clear_type_guides_splines(Operator):
    bl_idname = "perspective_splines.clear_type_guides"
    bl_label = "Clear Type VPs & Lines"
    bl_options = {'REGISTER', 'UNDO'}
    type_filter_prop: StringProperty(name="Type to Clear", default="")
    def execute(self, context):
        tool_settings = context.scene.perspective_tool_settings_splines
        type_key = self.type_filter_prop if self.type_filter_prop else tool_settings.current_perspective_type
        if type_key == 'NONE' and not self.type_filter_prop:
            self.report({'INFO'}, "No type selected/specified to clear.")
            return {'CANCELLED'}
        print(f"Clearing VPs & Guides for type: {type_key}")
        vp_prefixes_remove, guide_prefixes_clear = [], []
        if type_key == 'ONE_POINT':
            vp_prefixes_remove.append(VP_TYPE_SPECIFIC_PREFIX_MAP['ONE_POINT'])
            guide_prefixes_clear.append("1P_Guides")
        elif type_key == 'TWO_POINT':
            vp_prefixes_remove.append(VP_TYPE_SPECIFIC_PREFIX_MAP['TWO_POINT'])
            guide_prefixes_clear.extend(["2P_Guides_VP1", "2P_Guides_VP2", "2P_Guides_Vertical"])
        elif type_key == 'THREE_POINT':
            vp_prefixes_remove.append(VP_TYPE_SPECIFIC_PREFIX_MAP['THREE_POINT_H'])
            vp_prefixes_remove.append(VP_TYPE_SPECIFIC_PREFIX_MAP['THREE_POINT_V'])
            guide_prefixes_clear.extend(["3P_Guides_H1", "3P_Guides_H2", "3P_Guides_V"])
        elif type_key == 'FISH_EYE':
            vp_prefixes_remove.append(VP_TYPE_SPECIFIC_PREFIX_MAP['FISH_EYE'])
            guide_prefixes_clear.append("FE_Guides")
        
        all_scene_vps = get_vanishing_points() # Get all once
        for prefix in vp_prefixes_remove:
            for vp in list(all_scene_vps): # Iterate copy
                if vp.name.startswith(prefix):
                    try: bpy.data.objects.remove(vp, do_unlink=True)
                    except: pass
        if guide_prefixes_clear: clear_guides_with_prefix(context, guide_prefixes_clear)
        try: update_dynamic_horizon_line_curve(context)
        except Exception as e: print(f"Error updating horizon after type clear: {e}")
        self.report({'INFO'}, f"Cleared VPs & Guides for: {type_key}.")
        return {'FINISHED'}

class PERSPECTIVE_OT_clear_just_guides(Operator):
    bl_idname = "perspective_splines.clear_just_guides"
    bl_label = "Clear ONLY Guide Lines"
    bl_options = {'REGISTER', 'UNDO'}
    def execute(self, context):
        prefixes = ["1P_Guides", "2P_Guides_VP1", "2P_Guides_VP2", "2P_Guides_Vertical",
                    "3P_Guides_H1", "3P_Guides_H2", "3P_Guides_V", "FE_Guides"]
        count = clear_guides_with_prefix(context, prefixes)
        self.report({'INFO'}, f"Cleared {count} guide objects." if count > 0 else "No guides to clear.")
        return {'FINISHED'}

class PERSPECTIVE_OT_clear_horizon_spline(Operator):
    bl_idname = "perspective_splines.clear_horizon"
    bl_label = "Clear Horizon Elements"
    bl_options = {'REGISTER', 'UNDO'}
    def execute(self, context):
        cleared = 0
        hz_ctrl = get_horizon_control_object()
        if hz_ctrl:
            try: bpy.data.objects.remove(hz_ctrl, do_unlink=True); cleared+=1
            except: pass
        hz_curve = get_horizon_curve_object()
        if hz_curve:
            try:
                if hz_curve.data and hz_curve.data.name in bpy.data.curves and hz_curve.data.users <=1:
                    bpy.data.curves.remove(hz_curve.data)
                bpy.data.objects.remove(hz_curve, do_unlink=True); cleared+=1
            except: pass
        self.report({'INFO'}, "Horizon elements cleared." if cleared > 0 else "No horizon elements to clear.")
        try: update_dynamic_horizon_line_curve(context) # Should effectively hide it
        except Exception as e: print(f"Error updating horizon after clear_horizon: {e}")
        return {'FINISHED'}

class PERSPECTIVE_OT_clear_all_perspective_splines(Operator):
    bl_idname = "perspective_splines.clear_all"
    bl_label = "Clear ALL Perspective Helpers"
    bl_options = {'REGISTER', 'UNDO'}
    def execute(self, context):
        print("Attempting to clear ALL perspective data...")
        for vp in get_vanishing_points(): # Get all VPs regardless of type
            try: bpy.data.objects.remove(vp, do_unlink=True)
            except Exception as e: print(f"  Failed to remove VP {vp.name}: {e}")
        try: bpy.ops.perspective_splines.clear_horizon('EXEC_DEFAULT')
        except Exception as e: print(f"  Failed to clear horizon elements: {e}")
        all_guide_prefixes = ["1P_Guides", "2P_Guides_VP1", "2P_Guides_VP2", "2P_Guides_Vertical",
                              "3P_Guides_H1", "3P_Guides_H2", "3P_Guides_V", "FE_Guides"]
        clear_guides_with_prefix(context, all_guide_prefixes)
        try: update_dynamic_horizon_line_curve(context)
        except Exception as e: print(f"  Error updating horizon post clear all: {e}")
        self.report({'INFO'}, "Cleared ALL perspective data.")
        return {'FINISHED'}

class PERSPECTIVE_OT_generate_one_point_splines(Operator):
    bl_idname = "perspective_splines.generate_one_point"
    bl_label = "Generate 1P Lines"
    bl_options = {'REGISTER', 'UNDO'}
    
    @classmethod
    def create_default_one_point(cls, context):
        ts = context.scene.perspective_tool_settings_splines
        name = VP_TYPE_SPECIFIC_PREFIX_MAP['ONE_POINT'] + "_1"
        existing_vp = bpy.data.objects.get(name)
        loc = Vector((0,0,0)) # Default location
        if existing_vp:
            loc = existing_vp.location.copy()
        else:
            hc = get_horizon_control_object()
            if hc:
                loc = Vector((0, 0, hc.location.z)) # Default X, Y at origin, Z from horizon control
            else:
                loc = Vector((0, 0, ts.horizon_y_level)) # Fallback to tool setting for Z

        add_vp_empty_if_missing(context, name, loc, ts.one_point_vp_empty_color)
    
    def execute(self, context):
        ts = context.scene.perspective_tool_settings_splines
        vps_check = get_vanishing_points('ONE_POINT')
        
        if not get_horizon_control_object() and not vps_check:
            try:
                bpy.ops.perspective_splines.generate_horizon('EXEC_DEFAULT')
            except Exception as e:
                print(f"Error ensuring horizon for 1P (no VP, no HC): {e}")

        PERSPECTIVE_OT_generate_one_point_splines.create_default_one_point(context)
        
        vps = get_vanishing_points('ONE_POINT') 
        if not vps:
            self.report({'ERROR'}, "1P VP not found or could not be created.")
            return {'CANCELLED'}
        
        if abs(ts.horizon_y_level - vps[0].location.z) > 0.001 :
             ts.horizon_y_level = vps[0].location.z 

        try: update_vp_empty_colors(ts, context)
        except Exception as e: print(f"Error updating VP colors for 1P: {e}")
        
        guides_coll = get_guides_collection(context)
        clear_guides_with_prefix(context, ["1P_Guides"]) # Clear existing 1P guides
        vp_loc = vps[0].location.copy()
        spline_data = []
        ext = ts.one_point_line_extension

        if ts.one_point_draw_radial:
            spline_data.extend(generate_radial_lines_in_plane(vp_loc, ts.one_point_grid_density_radial, ext, 'XZ'))
        
        if ts.one_point_draw_ortho_x:
            half_grid_world_extent_x = ts.one_point_grid_extent * ext * 0.5 
            vertical_spacing_world = ts.one_point_grid_extent * ext * 0.2 
            density_x = ts.one_point_grid_density_ortho_x
            for i in range(density_x + 1):
                off_z_factor = (i / density_x - 0.5) * 2.0 if density_x > 0 else 0 
                curr_z = vp_loc.z + off_z_factor * (vertical_spacing_world / 2.0)
                spline_data.append([
                    Vector((vp_loc.x - half_grid_world_extent_x, vp_loc.y, curr_z)),
                    Vector((vp_loc.x + half_grid_world_extent_x, vp_loc.y, curr_z))
                ])
        
        if ts.one_point_draw_ortho_y:
            half_grid_world_extent_z = ts.one_point_grid_extent * ext * 0.5 
            horizontal_spacing_world = ts.one_point_grid_extent * ext * 0.2 
            density_y = ts.one_point_grid_density_ortho_y
            for i in range(density_y + 1):
                off_x_factor = (i / density_y - 0.5) * 2.0 if density_y > 0 else 0
                curr_x = vp_loc.x + off_x_factor * (horizontal_spacing_world / 2.0)
                spline_data.append([
                    Vector((curr_x, vp_loc.y, vp_loc.z - half_grid_world_extent_z)),
                    Vector((curr_x, vp_loc.y, vp_loc.z + half_grid_world_extent_z))
                ])

        if not spline_data:
            self.report({'INFO'}, "No 1P lines to generate based on current settings.")
            try: update_dynamic_horizon_line_curve(context)
            except Exception as e: print(f"Error updating horizon (no 1P lines generated): {e}")
            return {'FINISHED'}

        # <<<< MODIFICATION IS HERE >>>>
        opac = ts.guide_curves_opacity # Get global opacity from settings
        thickness = ts.guide_curves_thickness # Get global thickness
        created_count = 0
        for i, pts_list in enumerate(spline_data): 
            # Call create_curve_object WITHOUT the color_rgb argument
            if create_curve_object(context, f"1P_Guides_{i+1}", [pts_list], guides_coll,
                                thickness, opac): # Pass thickness and opacity
                created_count +=1
        # <<<< END OF MODIFICATION >>>>
                                
        self.report({'INFO'}, f"Generated {created_count} 1P line objects.")
        try: update_dynamic_horizon_line_curve(context)
        except Exception as e: print(f"Error updating horizon after 1P gen: {e}")
        return {'FINISHED'}


# (Place these after PERSPECTIVE_OT_generate_one_point_splines)

class PERSPECTIVE_OT_create_2p_vps_if_needed(Operator):
    """Helper to ensure 2P VPs exist, called by specific 2P line generators."""
    bl_idname = "perspective_splines.create_2p_vps_if_needed"
    bl_label = "Ensure 2P VPs"
    bl_options = {'REGISTER', 'INTERNAL'}

# Inside class PERSPECTIVE_OT_create_2p_vps_if_needed(Operator):
    # Inside class PERSPECTIVE_OT_create_2p_vps_if_needed(Operator):

    @classmethod
    def create_default_two_point_vps(cls, context):
        print("DEBUG: create_default_two_point_vps CALLED")
        ts = context.scene.perspective_tool_settings_splines
        prefix = VP_TYPE_SPECIFIC_PREFIX_MAP['TWO_POINT']
        helpers_coll = get_helpers_collection(context) # Ensure helpers collection exists

        # 1. Ensure Horizon Control Object and determine default Z for NEW VPs
        horizon_ctrl = get_horizon_control_object()
        if not horizon_ctrl:
            print("DEBUG 2P VP Create: No horizon control, attempting to generate one.")
            try:
                # Call generate_horizon operator to create the control and visual
                bpy.ops.perspective_splines.generate_horizon('EXEC_DEFAULT')
                horizon_ctrl = get_horizon_control_object() # Try to get it again
                if not horizon_ctrl:
                    print("DEBUG 2P VP Create: CRITICAL - Failed to generate/get horizon control object.")
                    # Fallback to tool settings if all else fails for Z
                    default_hz_z_for_new_vps = ts.horizon_y_level
                else:
                    default_hz_z_for_new_vps = horizon_ctrl.location.z
            except Exception as e:
                print(f"DEBUG 2P VP Create: Error generating horizon: {e}")
                default_hz_z_for_new_vps = ts.horizon_y_level # Fallback
        else:
            default_hz_z_for_new_vps = horizon_ctrl.location.z
            # Sync tool setting with existing horizon control if they differ
            if abs(ts.horizon_y_level - horizon_ctrl.location.z) > 0.001:
                ts.horizon_y_level = horizon_ctrl.location.z


        print(f"DEBUG: Default Z for new 2P VPs will be: {default_hz_z_for_new_vps}")

        vp_definitions = [
            {"name_suffix": "_1", "default_x": -10.0, "color_prop_name": "two_point_vp1_empty_color"},
            {"name_suffix": "_2", "default_x": 10.0,  "color_prop_name": "two_point_vp2_empty_color"}
        ]
        
        vps_changed_or_created = False
        created_vps_for_horizon_update = []

        for vp_def in vp_definitions:
            vp_name = prefix + vp_def["name_suffix"]
            vp_color_setting = getattr(ts, vp_def["color_prop_name"])
            
            existing_vp = bpy.data.objects.get(vp_name)

            if existing_vp:
                print(f"DEBUG: VP {vp_name} exists. Preserving location: {existing_vp.location}")
                # Ensure it's in the correct collection
                if existing_vp.name not in helpers_coll.objects:
                    print(f"DEBUG: Linking existing VP {vp_name} to helpers collection.")
                    # Unlink from other collections if necessary before linking here to avoid multi-collection link
                    for coll in existing_vp.users_collection:
                        if coll != helpers_coll:
                            coll.objects.unlink(existing_vp)
                    helpers_coll.objects.link(existing_vp)

                # Update color if different
                current_color_tuple = tuple(round(c, 4) for c in existing_vp.color)
                setting_color_tuple = tuple(round(c, 4) for c in vp_color_setting)
                if current_color_tuple != setting_color_tuple:
                    print(f"DEBUG: Updating color for existing VP {vp_name}")
                    existing_vp.color = list(vp_color_setting)
                    vps_changed_or_created = True
                created_vps_for_horizon_update.append(existing_vp) # Add for horizon update
            else:
                # VP does not exist, create it
                default_loc = Vector((vp_def["default_x"], 0.0, default_hz_z_for_new_vps))
                print(f"DEBUG: Creating NEW VP: {vp_name} at {default_loc}")
                new_vp = add_vp_empty_if_missing(context, vp_name, default_loc, vp_color_setting)
                if new_vp: # add_vp_empty_if_missing returns the object
                    vps_changed_or_created = True
                    created_vps_for_horizon_update.append(new_vp)
                else:
                    print(f"DEBUG: FAILED to create VP {vp_name}")
        
        if vps_changed_or_created:
            print("DEBUG: At least one 2P VP was created or its color updated.")
            update_vp_empty_colors(ts, context) # Update all VP empty colors based on settings
        
        # Always try to update the horizon line for 2P mode, as it's defined by the VPs.
        # update_dynamic_horizon_line_curve will check if enough VPs exist.
        print("DEBUG: Calling update_dynamic_horizon_line_curve from create_default_two_point_vps")
        update_dynamic_horizon_line_curve(context)


class PERSPECTIVE_OT_generate_2p_vp1_lines(Operator):
    bl_idname = "perspective_splines.generate_2p_vp1_lines"
    bl_label = "Generate 2P VP1 Lines"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        ts = context.scene.perspective_tool_settings_splines
        bpy.ops.perspective_splines.create_2p_vps_if_needed()

        vps = get_vanishing_points('TWO_POINT')
        if not vps:
            self.report({'ERROR'}, "2P VP1 not found. Create VPs first."); return {'CANCELLED'}
        vp1 = vps[0] # Assumes sorted, VP_2P_1

        guides_coll = get_guides_collection(context)
        clear_guides_with_prefix(context, ["2P_Guides_VP1_"]) # Note the underscore
        ext = ts.two_point_line_extension
        
        lines_data = generate_radial_lines_in_plane(vp1.location.copy(), ts.two_point_grid_density_vp1, ext, 'XZ')
        if not lines_data:
            self.report({'INFO'}, "No VP1 lines to generate."); return {'FINISHED'}
        
        opac = ts.guide_curves_opacity
        thickness = ts.guide_curves_thickness
        created_count = 0
        for i, pts_list in enumerate(lines_data):
            if create_curve_object(context, f"2P_Guides_VP1_{i+1}", [pts_list], guides_coll, thickness, opac):
                created_count += 1
        self.report({'INFO'}, f"Generated {created_count} 2P VP1 lines.")
        update_dynamic_horizon_line_curve(context)
        return {'FINISHED'}

class PERSPECTIVE_OT_generate_2p_vp2_lines(Operator):
    bl_idname = "perspective_splines.generate_2p_vp2_lines"
    bl_label = "Generate 2P VP2 Lines"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        ts = context.scene.perspective_tool_settings_splines
        bpy.ops.perspective_splines.create_2p_vps_if_needed()

        vps = get_vanishing_points('TWO_POINT')
        if len(vps) < 2:
            self.report({'ERROR'}, "2P VP2 not found. Create VPs first."); return {'CANCELLED'}
        vp2 = vps[1] # Assumes sorted, VP_2P_2

        guides_coll = get_guides_collection(context)
        clear_guides_with_prefix(context, ["2P_Guides_VP2_"]) # Note the underscore
        ext = ts.two_point_line_extension
        
        lines_data = generate_radial_lines_in_plane(vp2.location.copy(), ts.two_point_grid_density_vp2, ext, 'XZ')
        if not lines_data:
            self.report({'INFO'}, "No VP2 lines to generate."); return {'FINISHED'}

        opac = ts.guide_curves_opacity
        thickness = ts.guide_curves_thickness
        created_count = 0
        for i, pts_list in enumerate(lines_data):
            if create_curve_object(context, f"2P_Guides_VP2_{i+1}", [pts_list], guides_coll, thickness, opac):
                created_count +=1
        self.report({'INFO'}, f"Generated {created_count} 2P VP2 lines.")
        update_dynamic_horizon_line_curve(context)
        return {'FINISHED'}

class PERSPECTIVE_OT_generate_2p_vertical_lines(Operator):
    bl_idname = "perspective_splines.generate_2p_vertical_lines"
    bl_label = "Generate 2P Vertical Lines"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        ts = context.scene.perspective_tool_settings_splines
        bpy.ops.perspective_splines.create_2p_vps_if_needed() # Ensure VPs exist for context

        vps = get_vanishing_points('TWO_POINT')
        if len(vps) < 2:
            self.report({'ERROR'}, "2P VPs not found for vertical line generation."); return {'CANCELLED'}
        vp1_loc, vp2_loc = vps[0].location.copy(), vps[1].location.copy()

        guides_coll = get_guides_collection(context)
        clear_guides_with_prefix(context, ["2P_Guides_Vertical_"]) # Note the underscore
        
        verts_data = []
        num_verts = ts.two_point_grid_density_vertical
        if num_verts >= 0:
            h = ts.two_point_grid_height
            y_off = ts.two_point_grid_depth_offset
            x_space = ts.two_point_verticals_x_spacing_factor
            avg_vp_x = (vp1_loc.x + vp2_loc.x) / 2.0
            avg_vp_y = (vp1_loc.y + vp2_loc.y) / 2.0 
            horizon_z = vp1_loc.z 
            vp_x_dist = abs(vp1_loc.x - vp2_loc.x)
            ext_fallback = ts.two_point_line_extension # Use this if VPs are too close
            spread_width = vp_x_dist * x_space if vp_x_dist > 0.1 else ext_fallback * 0.5 * x_space
            start_x = avg_vp_x - spread_width / 2.0
            plane_y = avg_vp_y + y_off
            
            for i in range(num_verts + 1): 
                t = (i / num_verts) if num_verts > 0 else 0.5 
                curr_x = start_x + t * spread_width
                verts_data.append([Vector((curr_x, plane_y, horizon_z - h/2.0)), 
                                   Vector((curr_x, plane_y, horizon_z + h/2.0))])
        
        if not verts_data:
            self.report({'INFO'}, "No Vertical lines to generate."); return {'FINISHED'}

        opac = ts.guide_curves_opacity
        thickness = ts.guide_curves_thickness
        created_count = 0
        for i, pts_list in enumerate(verts_data):
            create_curve_object(context, f"2P_Guides_Vertical_{i+1}", [pts_list], guides_coll, thickness, opac)
            created_count += 1
        self.report({'INFO'}, f"Generated {created_count} 2P Vertical lines.")
        update_dynamic_horizon_line_curve(context)
        return {'FINISHED'}

    
# (Around line 1050, after generate_two_point and before generate_fish_eye)

class PERSPECTIVE_OT_create_3p_vps_if_needed(Operator):
    """Helper to ensure 3P VPs exist, called by specific 3P line generators."""
    bl_idname = "perspective_splines.create_3p_vps_if_needed"
    bl_label = "Ensure 3P VPs"
    bl_options = {'REGISTER', 'INTERNAL'} # Internal, not for UI

    # Inside class PERSPECTIVE_OT_create_3p_vps_if_needed(Operator):
    @classmethod
    def create_default_three_point_vps(cls, context):
        ts = context.scene.perspective_tool_settings_splines
        h_pref = VP_TYPE_SPECIFIC_PREFIX_MAP['THREE_POINT_H']
        v_pref = VP_TYPE_SPECIFIC_PREFIX_MAP['THREE_POINT_V']
        
        horizon_ctrl = get_horizon_control_object()
        # Initial hz_z for NEW VPs if no horizon control exists
        default_hz_z_for_new_vps = ts.horizon_y_level 
        if horizon_ctrl:
            default_hz_z_for_new_vps = horizon_ctrl.location.z

        # --- VP H1 ---
        vp_h1_name = h_pref + "_1"
        vp_h1_obj = bpy.data.objects.get(vp_h1_name)
        loc_h1 = Vector((-10, 0, default_hz_z_for_new_vps)) # Default for new VP
        if vp_h1_obj:
            loc_h1 = vp_h1_obj.location.copy() # Preserve existing location fully
            # If you want H VPs to always snap to horizon control if it exists, uncomment next line
            # if horizon_ctrl: loc_h1.z = horizon_ctrl.location.z
        else: # If creating new H VP and horizon control exists, place it on that horizon
            if horizon_ctrl: loc_h1.z = horizon_ctrl.location.z


        # --- VP H2 ---
        vp_h2_name = h_pref + "_2"
        vp_h2_obj = bpy.data.objects.get(vp_h2_name)
        loc_h2 = Vector((10, 0, default_hz_z_for_new_vps)) # Default for new VP
        if vp_h2_obj:
            loc_h2 = vp_h2_obj.location.copy() # Preserve existing location fully
            # If you want H VPs to always snap to horizon control if it exists, uncomment next line
            # if horizon_ctrl: loc_h2.z = horizon_ctrl.location.z
        else: # If creating new H VP and horizon control exists, place it on that horizon
            if horizon_ctrl: loc_h2.z = horizon_ctrl.location.z

        # --- VP V ---
        vp_v1_name = v_pref + "_1"
        vp_v1_obj = bpy.data.objects.get(vp_v1_name)
        # Default V VP location: X centered between H VPs, Y at their average, Z below H1 (or a fixed offset)
        avg_h_vp_x = (loc_h1.x + loc_h2.x) / 2.0
        avg_h_vp_y = (loc_h1.y + loc_h2.y) / 2.0 # Consider Y as well
        default_v_vp_z = loc_h1.z - 10 # Default below H1's current Z
        
        loc_v1 = Vector((avg_h_vp_x, avg_h_vp_y, default_v_vp_z))
        if vp_v1_obj:
            loc_v1 = vp_v1_obj.location.copy() # Preserve existing V VP location fully

        defs = [
            {"name": vp_h1_name, "loc": loc_h1, "color": ts.three_point_vp_h1_empty_color},
            {"name": vp_h2_name, "loc": loc_h2, "color": ts.three_point_vp_h2_empty_color},
            {"name": vp_v1_name, "loc": loc_v1, "color": ts.three_point_vp_v_empty_color}
        ]
        
        any_vp_created_or_moved = False
        for d_def in defs:
            existing_vp = bpy.data.objects.get(d_def["name"])
            if not existing_vp:
                add_vp_empty_if_missing(context, d_def["name"], d_def["loc"], d_def["color"])
                any_vp_created_or_moved = True
            else:
                # Update color, and only update location if it's a new default (which it isn't here if exists)
                # or if a specific snapping logic is re-applied (e.g. H VPs to horizon)
                # For full freedom, we only update color if it exists.
                # However, if the user moves the Horizon Control, we MIGHT want H VPs to follow.
                # This is a design choice. Current logic: preserve user's manual placement.
                if existing_vp.color != Vector(d_def["color"]): # Comparing Vector(color) to list
                    existing_vp.color = list(d_def["color"])
                    any_vp_created_or_moved = True # Technically only color changed, but can trigger redraws

                # Optional: If you want H VPs to *always* snap to the horizon control if it's moved by user:
                # if d_def["name"].startswith(h_pref) and horizon_ctrl:
                #     if abs(existing_vp.location.z - horizon_ctrl.location.z) > 0.001:
                #         existing_vp.location.z = horizon_ctrl.location.z
                #         any_vp_created_or_moved = True


        if any_vp_created_or_moved: # Or if VP colors changed
            update_vp_empty_colors(ts, context) # Update all VP colors based on settings
        
        # Horizon line for 3P mode should be drawn between H_VP1 and H_VP2
        # This means update_dynamic_horizon_line_curve will use their current Z values.
        update_dynamic_horizon_line_curve(context)


    def execute(self, context):
        PERSPECTIVE_OT_create_3p_vps_if_needed.create_default_three_point_vps(context)
        return {'FINISHED'}


class PERSPECTIVE_OT_generate_3p_h1_lines(Operator):
    bl_idname = "perspective_splines.generate_3p_h1_lines"
    bl_label = "Generate 3P H-VP1 Lines"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        ts = context.scene.perspective_tool_settings_splines
        bpy.ops.perspective_splines.create_3p_vps_if_needed() # Ensure VPs exist

        vps_h = get_vanishing_points('THREE_POINT_H')
        if not vps_h:
            self.report({'ERROR'}, "3P H-VP1 not found. Create VPs first."); return {'CANCELLED'}
        vp_h1 = vps_h[0] # Assumes sorted, VP_3P_H_1

        guides_coll = get_guides_collection(context)
        clear_guides_with_prefix(context, ["3P_Guides_H1"]) # Clear only H1 lines
        ext = ts.three_point_line_extension
        
        lines_data = generate_radial_lines_in_plane(vp_h1.location.copy(), ts.three_point_vp_h1_density, ext, 'XZ')
        if not lines_data:
            self.report({'INFO'}, "No H1 lines to generate."); return {'FINISHED'}
        
        opac = ts.guide_curves_opacity
        created_count = 0
        for i, pts_list in enumerate(lines_data):
            if create_curve_object(context, f"3P_Guides_H1_{i+1}", [pts_list], guides_coll, ts.guide_curves_thickness, opac):
                created_count += 1
        self.report({'INFO'}, f"Generated {created_count} 3P H-VP1 lines.")
        update_dynamic_horizon_line_curve(context)
        return {'FINISHED'}

class PERSPECTIVE_OT_generate_3p_h2_lines(Operator):
    bl_idname = "perspective_splines.generate_3p_h2_lines"
    bl_label = "Generate 3P H-VP2 Lines"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        ts = context.scene.perspective_tool_settings_splines
        bpy.ops.perspective_splines.create_3p_vps_if_needed()

        vps_h = get_vanishing_points('THREE_POINT_H')
        if len(vps_h) < 2:
            self.report({'ERROR'}, "3P H-VP2 not found. Create VPs first."); return {'CANCELLED'}
        vp_h2 = vps_h[1] # Assumes sorted, VP_3P_H_2

        guides_coll = get_guides_collection(context)
        clear_guides_with_prefix(context, ["3P_Guides_H2"])
        ext = ts.three_point_line_extension
        
        lines_data = generate_radial_lines_in_plane(vp_h2.location.copy(), ts.three_point_vp_h2_density, ext, 'XZ')
        if not lines_data:
            self.report({'INFO'}, "No H2 lines to generate."); return {'FINISHED'}

        opac = ts.guide_curves_opacity
        created_count = 0
        for i, pts_list in enumerate(lines_data):
            if create_curve_object(context, f"3P_Guides_H2_{i+1}", [pts_list], guides_coll, ts.guide_curves_thickness, opac):
                created_count +=1
        self.report({'INFO'}, f"Generated {created_count} 3P H-VP2 lines.")
        update_dynamic_horizon_line_curve(context)
        return {'FINISHED'}

class PERSPECTIVE_OT_generate_3p_v_lines(Operator):
    bl_idname = "perspective_splines.generate_3p_v_lines"
    bl_label = "Generate 3P V-VP Lines"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        ts = context.scene.perspective_tool_settings_splines
        bpy.ops.perspective_splines.create_3p_vps_if_needed()

        vps_v = get_vanishing_points('THREE_POINT_V')
        if not vps_v:
            self.report({'ERROR'}, "3P V-VP not found. Create VPs first."); return {'CANCELLED'}
        vp_v1 = vps_v[0]

        guides_coll = get_guides_collection(context)
        clear_guides_with_prefix(context, ["3P_Guides_V"])
        ext = ts.three_point_line_extension

        lines_data = generate_radial_lines_in_plane(vp_v1.location.copy(), ts.three_point_vp_v_density, ext, 'XZ')
        if not lines_data:
            self.report({'INFO'}, "No V lines to generate."); return {'FINISHED'}

        opac = ts.guide_curves_opacity
        created_count = 0
        for i, pts_list in enumerate(lines_data):
            if create_curve_object(context, f"3P_Guides_V_{i+1}", [pts_list], guides_coll, ts.guide_curves_thickness, opac):
                created_count +=1
        self.report({'INFO'}, f"Generated {created_count} 3P V-VP lines.")
        update_dynamic_horizon_line_curve(context) # V-VP doesn't define horizon, but good to update
        return {'FINISHED'}    


# (This class is after the 3P line generation operators and before align_camera)

class PERSPECTIVE_OT_generate_fish_eye_splines(Operator):
    bl_idname = "perspective_splines.generate_fish_eye"
    bl_label = "Generate FE Lines"
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def create_default_fish_eye_center(cls, context):
        print("DEBUG FishEye: create_default_fish_eye_center CALLED")
        ts = context.scene.perspective_tool_settings_splines
        helpers_coll = get_helpers_collection(context) # Ensure helpers collection exists

        fe_vp_name = VP_TYPE_SPECIFIC_PREFIX_MAP['FISH_EYE'] + "_1" # e.g., VP_FE_Center_1
        
        # Determine color for the VP empty
        vp_color = (0.5, 0.2, 0.8, 1.0) # Default if property doesn't exist
        if hasattr(ts, 'fish_eye_vp_empty_color'):
            vp_color = list(ts.fish_eye_vp_empty_color)
        
        existing_vp = bpy.data.objects.get(fe_vp_name)
        
        if existing_vp:
            print(f"DEBUG FishEye: VP {fe_vp_name} exists. Preserving location: {existing_vp.location}")
            # Ensure it's in the correct collection
            if existing_vp.name not in helpers_coll.objects:
                for coll in existing_vp.users_collection:
                    if coll != helpers_coll:
                        coll.objects.unlink(existing_vp)
                helpers_coll.objects.link(existing_vp)
            
            # Update color if different from setting
            current_color_tuple = tuple(round(c, 4) for c in existing_vp.color)
            setting_color_tuple = tuple(round(c, 4) for c in vp_color)
            if current_color_tuple != setting_color_tuple:
                print(f"DEBUG FishEye: Updating color for existing VP {existing_vp.name}")
                existing_vp.color = vp_color # Already a list or tuple
                update_vp_empty_colors(ts, context) # Call master color update
        else:
            # VP does not exist, create it at world origin (user can move it)
            default_loc = Vector((0.0, 0.0, 0.0))
            print(f"DEBUG FishEye: Creating NEW VP: {fe_vp_name} at {default_loc}")
            new_vp = add_vp_empty_if_missing(context, fe_vp_name, default_loc, vp_color)
            if new_vp:
                update_vp_empty_colors(ts, context) # Call master color update
            else:
                print(f"DEBUG FishEye: FAILED to create VP {fe_vp_name}")
        
        # FishEye typically doesn't have a horizon line in the same way,
        # but call update_dynamic_horizon_line_curve anyway in case it has a default behavior for 'NONE'
        # or if other types of horizon logic might apply. It will hide if no points are set.
        update_dynamic_horizon_line_curve(context)


    def execute(self, context):
        print("DEBUG FishEye: Execute operator CALLED")
        ts = context.scene.perspective_tool_settings_splines
        
        # Ensure the center VP exists or is created
        PERSPECTIVE_OT_generate_fish_eye_splines.create_default_fish_eye_center(context)
        
        fe_centers = get_vanishing_points('FISH_EYE') 
        if not fe_centers: 
            print("DEBUG FishEye Execute: FE Center VP NOT found after attempting creation.")
            self.report({'ERROR'}, "FE Center VP not found. Cannot generate lines."); return {'CANCELLED'}
        
        fe_center_obj = fe_centers[0] # Should be VP_FE_Center_1
        print(f"DEBUG FishEye Execute: Using FE Center VP: {fe_center_obj.name} at {fe_center_obj.location}")
        
        guides_coll = get_guides_collection(context)
        clear_guides_with_prefix(context, ["FE_Guides_"]) # Clear only FE guides (added underscore)
        
        center_loc = fe_center_obj.location.copy() # Use the current location of the VP
        n_lon, n_lat = ts.fish_eye_grid_radial, ts.fish_eye_grid_concentric
        segs, radius, h_scale = ts.fish_eye_segments_per_curve, ts.fish_eye_grid_radius, ts.fish_eye_horizontal_scale
        curves_data_to_create = [] 

        print(f"DEBUG FishEye Execute: n_lon={n_lon}, n_lat={n_lat}, draw_latitude={ts.fish_eye_draw_latitude}, radius={radius}")

        if n_lon > 0 and segs > 1: 
            print(f"DEBUG FishEye Execute: Generating {n_lon} longitude lines...")
            for i in range(n_lon):
                phi = (2 * math.pi * i) / n_lon 
                pts_longitude = []
                for j in range(segs + 1): 
                    theta = math.pi * j / segs 
                    x = radius * math.sin(theta) * math.cos(phi) * h_scale
                    y = radius * math.sin(theta) * math.sin(phi) 
                    z = radius * math.cos(theta)
                    # Add to the VP's current location
                    pts_longitude.append(center_loc + Vector((x,y,z))) 
                curves_data_to_create.append({'points_list': [pts_longitude], 'is_cyclic': False, 'name_suffix': f"Lon_{i}"})
        
        if ts.fish_eye_draw_latitude and n_lat > 0 and segs > 1: 
            print(f"DEBUG FishEye Execute: Generating {n_lat} latitude lines...")
            for i in range(1, n_lat + 1): 
                theta = math.pi * i / (n_lat + 1) 
                ring_radius_at_z = radius * math.sin(theta)
                z_offset_from_center = radius * math.cos(theta)
                pts_latitude = []
                for j in range(segs + 1): 
                    phi = (2 * math.pi * j) / segs 
                    x = ring_radius_at_z * math.cos(phi) * h_scale
                    y = ring_radius_at_z * math.sin(phi)
                    z_coord = z_offset_from_center # This is relative to the sphere's own center
                    # Add to the VP's current location
                    pts_latitude.append(center_loc + Vector((x,y,z_coord)))
                curves_data_to_create.append({'points_list': [pts_latitude], 'is_cyclic': True, 'name_suffix': f"Lat_{i}"})
        
        if not curves_data_to_create: 
            print("DEBUG FishEye Execute: No curve data was generated for FE lines.")
            self.report({'INFO'}, "No Fish Eye lines to generate based on current settings."); return {'FINISHED'}
        
        print(f"DEBUG FishEye Execute: Attempting to create {len(curves_data_to_create)} FE curve objects.")
        opac = ts.guide_curves_opacity 
        thickness = ts.guide_curves_thickness
        created_count = 0
        for i, curve_def in enumerate(curves_data_to_create):
            obj_name = f"FE_Guides_{curve_def['name_suffix']}"
            # create_curve_object uses random colors by default if color_rgb is not passed
            if create_curve_object(context, obj_name, curve_def['points_list'], guides_coll,
                                thickness, opac, is_cyclic=curve_def['is_cyclic'], curve_type='BEZIER'):
                created_count +=1
        
        self.report({'INFO'}, f"Generated {created_count} Fish Eye line objects.")
        return {'FINISHED'}

class PERSPECTIVE_OT_align_camera_splines(Operator):
    bl_idname = "perspective_splines.align_camera"
    bl_label = "Align Camera to Perspective"
    bl_options = {'REGISTER', 'UNDO'}
    @classmethod
    def poll(cls, context): return context.scene.camera is not None
    def execute(self, context):
        ts = context.scene.perspective_tool_settings_splines
        cam = context.scene.camera
        if not cam: # Should be caught by poll, but defensive
            self.report({'ERROR'}, "No active camera in scene.")
            return {'CANCELLED'}

        target_point = Vector((0,0,0)) # Point camera looks at
        cam_height_origin_z = 0.0 # Z level from which eye height is measured

        curr_type = ts.current_perspective_type
        horizon_ctrl = get_horizon_control_object()

        if curr_type == 'ONE_POINT':
            vps = get_vanishing_points('ONE_POINT')
            if vps: 
                target_point = vps[0].location.copy()
                cam_height_origin_z = vps[0].location.z
            elif horizon_ctrl: 
                cam_height_origin_z = horizon_ctrl.location.z
                target_point = Vector((0, 0, cam_height_origin_z)) # Target center of horizon
            else: # Fallback to tool setting
                cam_height_origin_z = ts.horizon_y_level
                target_point = Vector((0, 0, cam_height_origin_z))

        elif curr_type == 'TWO_POINT':
            vps = get_vanishing_points('TWO_POINT')
            if len(vps) >=2: 
                target_point = (vps[0].location + vps[1].location) / 2.0
                cam_height_origin_z = vps[0].location.z # VPs are on horizon
            elif horizon_ctrl:
                cam_height_origin_z = horizon_ctrl.location.z
                target_point = Vector((0, 0, cam_height_origin_z))
            else:
                cam_height_origin_z = ts.horizon_y_level
                target_point = Vector((0, 0, cam_height_origin_z))
        
        elif curr_type == 'THREE_POINT':
            vps_h = get_vanishing_points('THREE_POINT_H')
            # For 3P, typically target the center of the H_VPs on the horizon
            if len(vps_h) >=2: 
                target_point = (vps_h[0].location + vps_h[1].location) / 2.0
                cam_height_origin_z = vps_h[0].location.z
                # Optional: Could consider V_VP for target_point.z if desired for worm's/bird's eye view aiming
                # vps_v = get_vanishing_points('THREE_POINT_V')
                # if vps_v: target_point.z = vps_v[0].location.z 
            elif horizon_ctrl:
                cam_height_origin_z = horizon_ctrl.location.z
                target_point = Vector((0, 0, cam_height_origin_z))
            else:
                cam_height_origin_z = ts.horizon_y_level
                target_point = Vector((0, 0, cam_height_origin_z))

        elif curr_type == 'FISH_EYE':
            vps = get_vanishing_points('FISH_EYE')
            if vps: 
                target_point = vps[0].location.copy()
                cam_height_origin_z = vps[0].location.z # Camera level relative to FE center Z
            else: # Fallback to world origin if no FE center
                target_point = Vector((0,0,0))
                cam_height_origin_z = 0.0
        
        else: # 'NONE' or unhandled type
            if horizon_ctrl: 
                cam_height_origin_z = horizon_ctrl.location.z
                target_point = Vector((0, 0, cam_height_origin_z))
            else: 
                cam_height_origin_z = ts.horizon_y_level
                target_point = Vector((0, 0, cam_height_origin_z))
            self.report({'INFO'}, f"Aligning camera to default target at Z={cam_height_origin_z:.2f}.")

        # Position camera: typically behind target_point along Y, at eye height
        # Assuming standard Blender coordinate system where -Y is "into the screen" from front view
        cam.location = target_point + Vector((0, -ts.camera_distance, 0)) # Move back along Y
        cam.location.z = cam_height_origin_z + ts.camera_eye_height       # Set Z based on origin + eye height

        # Point camera towards target_point
        direction_to_target = target_point - cam.location
        if direction_to_target.length > 0.0001: # Avoid issues with zero-length vector
            # Using 'track_to_object_tuple' logic: (target_object, track_axis, up_axis)
            # We want camera's -Z axis to point towards target, Y axis as up.
            cam.rotation_euler = direction_to_target.to_track_quat('-Z', 'Y').to_euler('XYZ')
        
        self.report({'INFO'}, f"Camera aligned for {curr_type if curr_type != 'NONE' else 'default view'}.")
        return {'FINISHED'}

# This operator is now redundant if PERSPECTIVE_OT_merge_and_convert_to_gpencil is used from the UI.
# It's commented out in classes_splines. If you want to keep it for other purposes, ensure its context override is also robust.
# (This operator should be around line 1067 or after PERSPECTIVE_OT_align_camera_splines)
# Replace the existing PERSPECTIVE_OT_convert_to_grease_pencil with this:

# -----------------------------------------------------------
# UI Panel
# -----------------------------------------------------------
# -----------------------------------------------------------
# UI Panel
# -----------------------------------------------------------
# (This class is usually defined after all your operators and before the registration section)

class VIEW3D_PT_rogue_perspective_grids(Panel):
    bl_label = "Construction Grids"
    bl_idname = "VIEW3D_PT_rogue_perspective_grids"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'RogueAI' # Same tab as main panel
    bl_parent_id = "VIEW3D_PT_rogue_perspective_ai" # Make it a subpanel
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        layout = self.layout
        ts = context.scene.perspective_tool_settings_splines

        box = layout.box()
        box.label(text="Box Grid Parameters:")
        col = box.column(align=True)
        col.prop(ts, "grid_center", text="Center")
        col.prop(ts, "grid_size", text="Size")
        row = col.row(align=True)
        row.prop(ts, "grid_subdivisions_u", text="Subs U")
        row.prop(ts, "grid_subdivisions_v", text="Subs V")

        box.separator()
        box.label(text="Draw Planes:")
        col_planes = box.column(align=True)
        row1 = col_planes.row(align=True)
        row1.prop(ts, "grid_draw_front", text="Front", toggle=True)
        row1.prop(ts, "grid_draw_back", text="Back", toggle=True)
        row2 = col_planes.row(align=True)
        row2.prop(ts, "grid_draw_top", text="Top", toggle=True)
        row2.prop(ts, "grid_draw_bottom", text="Bottom", toggle=True)
        row3 = col_planes.row(align=True)
        row3.prop(ts, "grid_draw_left", text="Left", toggle=True)
        row3.prop(ts, "grid_draw_right", text="Right", toggle=True)
        
        layout.separator()
        layout.operator("perspective_splines.create_box_grid", text="Create/Update Box Grid", icon='MESH_GRID')
        
        # Corrected Clear Grid Planes button
        layout.operator("perspective_splines.clear_grid_planes", text="Clear Grid Planes", icon='X')
        
        layout.separator() 
        
        # Added Toggle Grid Visibility button
        toggle_op = layout.operator(
            PERSPECTIVE_OT_toggle_guide_visibility.bl_idname,
            text="Toggle Grid Visibility",
            icon='HIDE_OFF' # Initial icon, can be made dynamic if state is tracked
        )
        toggle_op.group_prefix = "GridPlane_"






class VIEW3D_PT_rogue_perspective_trimmer(bpy.types.Panel):
    bl_label = "Guide Clipper"
    bl_idname = "VIEW3D_PT_rogue_perspective_trimmer"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'RogueAI'
    bl_parent_id = "VIEW3D_PT_rogue_perspective_ai"
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        layout = self.layout
        ts = getattr(context.scene, "perspective_tool_settings_splines", None)
        if not ts:
            layout.label(text="Perspective settings not found.")
            return

        main_box = layout.box()
        col_main = main_box.column(align=True)

        col_main.label(text="Clip Guides to Camera Borders:")
        col_main.operator(
            "perspective_splines.clip_guides_to_camera",
            text="Clip Now",
            icon='MOD_LENGTH'
        )


    
class VIEW3D_PT_perspective_extraction(bpy.types.Panel):
    bl_label = "Perspective Extraction"
    bl_idname = "VIEW3D_PT_perspective_extraction"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'RogueAI'
    bl_description = "Use Grease Pencil strokes to extract perspective from a reference image."

    def draw(self, context):
        layout = self.layout
        layout.label(text="Draw at least two strokes on a GPencil object")
        layout.label(text="and ensure it is selected in Object Mode.")
        layout.operator("perspective_splines.extract_perspective_from_image", 
                          text="Extract 1P Perspective", icon='IMAGE_RGB')






class Rogue_Perspective_AI_PT_main(Panel):
    bl_label = "Rogue Perspective AI"
    bl_idname = "VIEW3D_PT_rogue_perspective_ai"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'RogueAI'

    @classmethod
    def poll(cls, context):
        return hasattr(context.scene, "perspective_tool_settings_splines") and context.scene.perspective_tool_settings_splines

    def draw(self, context):
        layout = self.layout
        ts = context.scene.perspective_tool_settings_splines
    
    # --- Helper method for the Finalize Guides section ---
    def draw_finalize_guides_section(self, layout, context):
        tool_settings = context.scene.perspective_tool_settings_splines
        current_perspective_type = tool_settings.current_perspective_type

        finalize_box = layout.box()
        finalize_box.label(text="Finalize Guides:")

        if  current_perspective_type != 'NONE' and \
            current_perspective_type in PERSPECTIVE_OT_merge_specific_guides.GUIDE_GROUP_DEFS:
        
            type_specific_merge_box = finalize_box.box()
            # ... (selective merge buttons as before) ...
            guide_groups_for_type = PERSPECTIVE_OT_merge_specific_guides.GUIDE_GROUP_DEFS[current_perspective_type]
            # (Loop to create specific merge buttons remains the same)
            for group_id_key, (_, name_suggestion_part) in guide_groups_for_type.items():
                label_text = name_suggestion_part.replace(current_perspective_type.replace('_',''), "").replace("_Lines", "").replace("Lines","").replace("_", " ").strip().title()
                if not label_text: label_text = group_id_key.replace("_LINES", "").replace("_", " ").strip().title()
                op = type_specific_merge_box.operator(PERSPECTIVE_OT_merge_specific_guides.bl_idname, text=f"Merge {label_text}")
                op.group_identifier = group_id_key
        
            op_all_current = type_specific_merge_box.operator(PERSPECTIVE_OT_merge_specific_guides.bl_idname, text=f"Merge All {current_perspective_type.replace('_', ' ').title()} Guides")
            op_all_current.group_identifier = "ALL_CURRENT_TYPE"

        finalize_box.separator()
        finalize_box.operator(PERSPECTIVE_OT_merge_guides.bl_idname, icon='OBJECT_DATAMODE') # "Merge All Visible Guides"
    
         # --- Show/Hide Section ---
        show_hide_box = layout.box()
        show_hide_box.label(text="Toggle Guide Visibility:")
        col_sh = show_hide_box.column(align=True)

        # Dynamically add show/hide buttons based on current perspective type definitions
        if current_perspective_type != 'NONE' and current_perspective_type in PERSPECTIVE_OT_merge_specific_guides.GUIDE_GROUP_DEFS:
              guide_groups = PERSPECTIVE_OT_merge_specific_guides.GUIDE_GROUP_DEFS[current_perspective_type]
              for group_key, (prefixes, name_part) in guide_groups.items():
                  # Use the first prefix as representative for the toggle operator
                  if prefixes:
                     op_sh = col_sh.operator(PERSPECTIVE_OT_toggle_guide_visibility.bl_idname, text=f"Toggle {name_part.replace('_Lines','').replace('_',' ')}", icon='HIDE_OFF') # Icon can be dynamic later
                     op_sh.group_prefix = prefixes[0] # e.g. "2P_Guides_VP1"
        else:
            col_sh.label(text="Select a perspective type to see visibility toggles.")
        

    # --- Main draw method for the panel ---
    def draw(self, context):
        layout = self.layout
        
        # Check if addon properties are initialized (poll should also catch this)
        if not hasattr(context.scene, "perspective_tool_settings_splines") or \
           not context.scene.perspective_tool_settings_splines:
            layout.label(text="Error: Addon properties not fully initialized.")
            # layout.operator("wm.operator_defaults") # Can be useful for debugging registration
            return
        
        ts = context.scene.perspective_tool_settings_splines

        # Mode selector
        layout.prop(ts, "current_perspective_type", text="Mode")
        layout.separator()

        # --- Horizon Line Section ---
        box_hz = layout.box()
        col_hz_main = box_hz.column()
        col_hz_main.label(text="Horizon Line (1P Setup / Visual):")
        row_hz_ctrl = col_hz_main.row(align=True)
        row_hz_ctrl.prop(ts, "horizon_y_level") # Uses name "1P Horizon Z"
        row_hz_ctrl.operator("perspective_splines.generate_horizon", text="Set/Update", icon='CON_SIZELIMIT')
        
        col_hz_props = col_hz_main.column(align=True)
        col_hz_props.prop(ts, "horizon_line_length")
        col_hz_props.prop(ts, "horizon_line_thickness")
        col_hz_props.prop(ts, "horizon_line_color", text="Color & Alpha")
        col_hz_main.operator("perspective_splines.clear_horizon", text="Clear Horizon Elements", icon='X')
        layout.separator()

        # --- Vanishing Point Controls ---
        box_vps = layout.box()
        col_vps_main = box_vps.column()
        col_vps_main.label(text="Vanishing Point Empties:")
        row_vps_ops = col_vps_main.row(align=True)
        row_vps_ops.operator("perspective_splines.add_vp_empty", text="Add Generic VP", icon='ADD')
        row_vps_ops.operator("perspective_splines.remove_selected_helper_empty", text="Remove Sel. VP/Ctrl", icon='REMOVE')
        
        vps_list = get_vanishing_points() # Gets all VPs
        if vps_list:
            vp_display_box = col_vps_main.box()
            for vp_obj in vps_list:
                row_vp_item = vp_display_box.row(align=True)
                row_vp_item.label(text=f"{vp_obj.name}", icon='EMPTY_DATA')
                # Individual location properties for finer control in UI
                loc_row = row_vp_item.row(align=True)
                loc_row.prop(vp_obj, "location", index=0, text="X")
                loc_row.prop(vp_obj, "location", index=1, text="Y")
                loc_row.prop(vp_obj, "location", index=2, text="Z")
        layout.separator()

        # --- Guide Lines General Appearance (Simplified) ---
        box_guides_app = layout.box()
        col_guides_app_main = box_guides_app.column()
        col_guides_app_main.label(text="Guide Lines General Appearance:")
        col_guides_props = col_guides_app_main.column(align=True)
        col_guides_props.prop(ts, "guide_curves_thickness")
        col_guides_props.prop(ts, "guide_curves_opacity")
        col_guides_app_main.operator("perspective_splines.clear_just_guides", text="Clear All Guide Lines", icon='BRUSH_DATA')
        layout.separator()

        # --- Perspective-specific Settings Panel ---
        if ts.current_perspective_type != 'NONE':
            type_settings_box = layout.box() 
            # Call the appropriate draw method for the current perspective type
            if ts.current_perspective_type == 'ONE_POINT':
                self.draw_one_point_panel(context, type_settings_box, ts)
            elif ts.current_perspective_type == 'TWO_POINT':
                self.draw_two_point_panel(context, type_settings_box, ts)
            elif ts.current_perspective_type == 'THREE_POINT':
                self.draw_three_point_panel(context, type_settings_box, ts)
            elif ts.current_perspective_type == 'FISH_EYE':
                self.draw_fish_eye_panel(context, type_settings_box, ts)
            layout.separator()

        # --- Finalize Guides Section (using the new helper method) ---
        self.draw_finalize_guides_section(layout, context)
        layout.separator()

        # --- Camera Alignment ---
        box_cam = layout.box()
        col_cam_main = box_cam.column()
        col_cam_main.label(text="Camera Alignment:")
        col_cam_props = col_cam_main.column(align=True)
        col_cam_props.prop(ts, "camera_eye_height")
        col_cam_props.prop(ts, "camera_distance")
        col_cam_main.operator("perspective_splines.align_camera", icon='CAMERA_DATA')
        layout.separator()
        
        # --- Master Clear Button ---
        layout.operator("perspective_splines.clear_all", text="Clear ALL Perspective Data", icon='TRASH')

    # --- Perspective-specific sub-panel drawing methods ---
    # (These should be the same as you had before, ensure they are correctly defined within this class)

    def draw_one_point_panel(self, context, box, settings): 
        col = box.column(align=True)
        col.label(text="One-Point Perspective Settings:")
        col.prop(settings, "one_point_vp_empty_color", text="VP Empty Color")
        col.separator()
        
        row_radial = col.row(align=True)
        row_radial.prop(settings, "one_point_draw_radial", toggle=True)
        if settings.one_point_draw_radial:
            row_radial.prop(settings, "one_point_grid_density_radial", text="Density")
        
        row_ortho_x = col.row(align=True)
        row_ortho_x.prop(settings, "one_point_draw_ortho_x", toggle=True)
        if settings.one_point_draw_ortho_x:
            row_ortho_x.prop(settings, "one_point_grid_density_ortho_x", text="Density")

        row_ortho_y = col.row(align=True)
        row_ortho_y.prop(settings, "one_point_draw_ortho_y", toggle=True)
        if settings.one_point_draw_ortho_y:
            row_ortho_y.prop(settings, "one_point_grid_density_ortho_y", text="Density")
        
        if settings.one_point_draw_ortho_x or settings.one_point_draw_ortho_y or settings.one_point_draw_radial:
             col.prop(settings, "one_point_grid_extent", text="Grid Extent Factor")
             col.prop(settings, "one_point_line_extension", text="Radial Line Length")

        box.operator("perspective_splines.generate_one_point", text="Generate/Update 1P Lines", icon='CURVE_PATH')

# Inside class Rogue_Perspective_AI_PT_main(Panel):

    def draw_two_point_panel(self, context, box, settings): # 'settings' is ts
        col = box.column(align=True)
        col.label(text="Two-Point Perspective Settings:")
        
        col.label(text="VP Empty Colors:")
        row_vp_colors = col.row(align=True)
        row_vp_colors.prop(settings, "two_point_vp1_empty_color", text="VP1")
        row_vp_colors.prop(settings, "two_point_vp2_empty_color", text="VP2")
        col.separator()
        
        col.prop(settings, "two_point_line_extension", text="Radial Line Length")
        col.separator()

        col.label(text="Guide Densities & Parameters:")
        
        # VP1 Lines
        sub_box_vp1 = col.box()
        sub_box_vp1.label(text="VP1 Lines:")
        sub_box_vp1.prop(settings, "two_point_grid_density_vp1", text="Density")
        sub_box_vp1.operator("perspective_splines.generate_2p_vp1_lines", text="Draw VP1 Lines")

        # VP2 Lines
        sub_box_vp2 = col.box()
        sub_box_vp2.label(text="VP2 Lines:")
        sub_box_vp2.prop(settings, "two_point_grid_density_vp2", text="Density")
        sub_box_vp2.operator("perspective_splines.generate_2p_vp2_lines", text="Draw VP2 Lines")
        
        # Vertical Lines
        sub_box_vert = col.box()
        sub_box_vert.label(text="Vertical Lines:")
        sub_box_vert.prop(settings, "two_point_grid_density_vertical", text="Density")
        if settings.two_point_grid_density_vertical > 0:
            sub_box_vert.prop(settings, "two_point_verticals_x_spacing_factor", text="X Spacing")
            sub_box_vert.prop(settings, "two_point_grid_height", text="Height")
            sub_box_vert.prop(settings, "two_point_grid_depth_offset", text="Y Offset")
        sub_box_vert.operator("perspective_splines.generate_2p_vertical_lines", text="Draw Vertical Lines")
        
        col.separator()
        col.operator("perspective_splines.create_2p_vps_if_needed", text="Create/Refresh 2P VPs", icon='EMPTY_AXIS')

    def draw_three_point_panel(self, context, box, settings): # 'settings' is ts
        col = box.column(align=True)
        col.label(text="Three-Point Perspective Settings:")
    
        col.label(text="VP Empty Colors:")
        row_vp_colors = col.row(align=True)
        row_vp_colors.prop(settings, "three_point_vp_h1_empty_color", text="H1")
        row_vp_colors.prop(settings, "three_point_vp_h2_empty_color", text="H2")
        row_vp_colors.prop(settings, "three_point_vp_v_empty_color", text="V")
        col.separator()
    
        col.prop(settings, "three_point_line_extension", text="Radial Line Length")
        col.separator()

        col.label(text="Guide Densities:")
        row_density1 = col.row(align=True)
        row_density1.prop(settings, "three_point_vp_h1_density", text="H1 Density")
        row_density1.prop(settings, "three_point_vp_h2_density", text="H2 Density")
        col.prop(settings, "three_point_vp_v_density", text="V Density")
        col.separator()

        col.label(text="Generate Lines:")
        col.operator("perspective_splines.generate_3p_h1_lines", text="Draw H-VP1 Lines", icon='CURVE_PATH')
        col.operator("perspective_splines.generate_3p_h2_lines", text="Draw H-VP2 Lines", icon='CURVE_PATH')
        col.operator("perspective_splines.generate_3p_v_lines", text="Draw V-VP Lines", icon='CURVE_PATH')
    
        # Button to create VPs if they don't exist, or refresh them.
        col.separator()
        col.operator("perspective_splines.create_3p_vps_if_needed", text="Create/Refresh 3P VPs", icon='EMPTY_AXIS')


    def draw_fish_eye_panel(self, context, box, settings):
        col = box.column(align=True)
        col.label(text="Fish Eye (Spherical Cage) Settings:")
        col.prop(settings, "fish_eye_grid_radius", text="Sphere Radius")
        
        row_grid_lines = col.row(align=True)
        row_grid_lines.prop(settings, "fish_eye_grid_radial", text="Longitudes")
        row_grid_lines.prop(settings, "fish_eye_grid_concentric", text="Latitudes")
        
        col.prop(settings, "fish_eye_segments_per_curve", text="Curve Smoothness")
        col.prop(settings, "fish_eye_horizontal_scale", text="Horizontal Scale")
        col.prop(settings, "fish_eye_draw_latitude", text="Draw Latitude Lines", toggle=True)
        # fish_eye_strength is defined in properties but not used in current generation logic.
        # If you use it later, add: col.prop(settings, "fish_eye_strength")
        
        box.operator("perspective_splines.generate_fish_eye", text="Generate/Update Fish Eye Lines", icon='MESH_UVSPHERE')
    
        


# -----------------------------------------------------------
# Depsgraph Handler
# -----------------------------------------------------------
_depsgraph_handler_active_splines = True # Global flag to prevent re-entrancy

def perspective_depsgraph_handler_splines(scene, depsgraph):
    global _depsgraph_handler_active_splines
    if not _depsgraph_handler_active_splines or not bpy.context.screen: # Ensure screen context exists
        return
    if not hasattr(scene, 'perspective_tool_settings_splines') or scene.perspective_tool_settings_splines is None:
        return

    # Attempt to get a valid context for updates if the default one isn't right
    context_for_update = bpy.context
    if context_for_update.scene != scene: # If handler triggered from a different scene context
        valid_context_found = False
        for window in bpy.context.window_manager.windows:
            if window.screen:
                for area in window.screen.areas:
                    if area.type == 'VIEW_3D':
                        for region in area.regions:
                            if region.type == 'WINDOW':
                                try:
                                    context_for_update = bpy.context.temp_override(window=window, area=area, region=region, screen=window.screen)
                                    if context_for_update.scene == scene: # Check if this override matches the depsgraph scene
                                        valid_context_found = True
                                        break
                                except Exception as e:
                                    # print(f"Depsgraph: Error creating temp_override: {e}")
                                    pass # Could not override, try next
                        if valid_context_found: break
            if valid_context_found: break
        if not valid_context_found:
            # print("Depsgraph: Could not find suitable VIEW_3D context for scene updates.")
            return # Cannot proceed without a valid context for the current scene

    tool_settings = scene.perspective_tool_settings_splines
    needs_horizon_recalc = False
    vp_moved_for_active_type = False

    # Disable handler during its execution to prevent loops
    _depsgraph_handler_active_splines = False
    try:
        for update in depsgraph.updates:
            if not hasattr(update.id, "name") or not update.is_updated_transform:
                continue
            
            obj_name = ""
            try: # ID might be a non-object type sometimes, so check its type
                if isinstance(update.id, bpy.types.Object):
                    obj_name = update.id.name
                else: # If it's not an object, skip (e.g. material update)
                    continue
            except AttributeError: # update.id might not always have .name if it's already unlinked
                continue

            # Horizon Control Object Moved
            if obj_name == HORIZON_CTRL_OBJ_NAME:
                horizon_ctrl_obj = scene.objects.get(HORIZON_CTRL_OBJ_NAME) # Use scene.objects
                if horizon_ctrl_obj:
                    new_z = horizon_ctrl_obj.location.z
                    if abs(tool_settings.horizon_y_level - new_z) > 0.001:
                        tool_settings.horizon_y_level = new_z # This will trigger its own update func
                    needs_horizon_recalc = True 
                    # For 2P/3P, if HC moves, VPs on horizon should follow via their generation logic.
                    # This depsgraph handler primarily updates the visual horizon line itself.
                    # And syncs tool_settings.horizon_y_level.
                    # The actual VP Z for 1P is now independent.

            # A Vanishing Point Empty Moved
            elif obj_name.startswith(VP_PREFIX):
                vp_obj_moved = scene.objects.get(obj_name)
                if vp_obj_moved:
                    current_type = tool_settings.current_perspective_type
                    # 1P: If the 1P VP moves, its Z defines the horizon.
                    if current_type == 'ONE_POINT' and vp_obj_moved.name.startswith(VP_TYPE_SPECIFIC_PREFIX_MAP['ONE_POINT']):
                        if abs(tool_settings.horizon_y_level - vp_obj_moved.location.z) > 0.001 :
                             tool_settings.horizon_y_level = vp_obj_moved.location.z # Update setting from VP
                        needs_horizon_recalc = True
                        vp_moved_for_active_type = True
                    # 2P: H VPs determine horizon.
                    elif current_type == 'TWO_POINT' and vp_obj_moved.name.startswith(VP_TYPE_SPECIFIC_PREFIX_MAP['TWO_POINT']):
                        # The horizon Z is derived from the VPs; if one moves, its Z should align with the other
                        # or the horizon control. The `create_default_two_point` and horizon update should handle this.
                        # Here, we just flag for recalc.
                        needs_horizon_recalc = True
                        vp_moved_for_active_type = True
                    # 3P: H VPs determine horizon.
                    elif current_type == 'THREE_POINT':
                        if vp_obj_moved.name.startswith(VP_TYPE_SPECIFIC_PREFIX_MAP['THREE_POINT_H']):
                            needs_horizon_recalc = True
                            vp_moved_for_active_type = True
                        # V_VP move doesn't directly change horizon line, but might affect guides if auto-updating guides here.
                        # For now, only H_VPs trigger horizon recalc.
                    
                    # If any VP moves, and auto-guide regeneration is desired, it would be triggered here.
                    # For now, we only update the horizon line visual. Guide regeneration is manual.

        if needs_horizon_recalc: # Also implies vp_moved_for_active_type if it was a relevant VP
            # Use the context_for_update we tried to establish
            update_dynamic_horizon_line_curve(context_for_update)

    except Exception as e:
        print(f"Error in perspective_depsgraph_handler_splines: {e}")
    finally:
        _depsgraph_handler_active_splines = True # Re-enable handler

# -----------------------------------------------------------
# Registration
# -----------------------------------------------------------
# Original relevant part:
#    PERSPECTIVE_OT_merge_guides,
#    PERSPECTIVE_OT_merge_and_convert_to_gpencil,
#    # Optionally, remove this if you don't want the old merge/convert functionality:
#    # PERSPECTIVE_OT_convert_to_grease_pencil,  <-- This was the old one
#    Rogue_Perspective_AI_PT_main,

# Change to include the new operator name:
# (This tuple is usually found near the end of your script, just before the register() and unregister() functions)

# (Near the end of your script)
classes_splines = (
    PerspectiveToolSettingsSplines,

    # --- Generation and Setup Operators ---
    PERSPECTIVE_OT_generate_horizon_spline,
    PERSPECTIVE_OT_add_vanishing_point_empty,
    PERSPECTIVE_OT_generate_one_point_splines,
    PERSPECTIVE_OT_create_2p_vps_if_needed,
    PERSPECTIVE_OT_generate_2p_vp1_lines,
    PERSPECTIVE_OT_generate_2p_vp2_lines,
    PERSPECTIVE_OT_generate_2p_vertical_lines,
    PERSPECTIVE_OT_create_3p_vps_if_needed,
    PERSPECTIVE_OT_generate_3p_h1_lines,
    PERSPECTIVE_OT_generate_3p_h2_lines,
    PERSPECTIVE_OT_generate_3p_v_lines,
    PERSPECTIVE_OT_generate_fish_eye_splines,
    PERSPECTIVE_OT_align_camera_splines,
    PERSPECTIVE_OT_create_box_grid,
    PERSPECTIVE_OT_clip_guides_to_camera,

    # --- New Extraction Operator ---
    PERSPECTIVE_OT_extract_perspective_from_image,
    
    PERSPECTIVE_OT_clear_grid_planes,
    
    # --- Clearing Operators ---
    PERSPECTIVE_OT_remove_selected_helper_empty,
    PERSPECTIVE_OT_clear_type_guides_splines,
    PERSPECTIVE_OT_clear_just_guides,
    PERSPECTIVE_OT_clear_horizon_spline,
    PERSPECTIVE_OT_clear_all_perspective_splines,
    
    # --- Merging Operators ---
    PERSPECTIVE_OT_merge_specific_guides,
    PERSPECTIVE_OT_merge_guides,
    
    # --- Visibility Operator ---
    PERSPECTIVE_OT_toggle_guide_visibility,
    
    # --- UI Panels ---
    Rogue_Perspective_AI_PT_main,
    VIEW3D_PT_rogue_perspective_grids,
    VIEW3D_PT_rogue_perspective_trimmer,
    VIEW3D_PT_perspective_extraction,  # <-- NEW extraction panel
)




def register():
    global _depsgraph_handler_active_splines, previous_perspective_type_on_switch
    for cls in classes_splines:
        try:
            bpy.utils.register_class(cls)
        except ValueError as e:
            print(f"Warning: Class {cls.__name__} already registered or error: {e}")

    try:
        bpy.types.Scene.perspective_tool_settings_splines = PointerProperty(type=PerspectiveToolSettingsSplines)
    except TypeError as e: # Already registered from a previous script run without full unregister
        print(f"Warning: perspective_tool_settings_splines already exists on Scene type: {e}")

    if perspective_depsgraph_handler_splines not in bpy.app.handlers.depsgraph_update_post:
        bpy.app.handlers.depsgraph_update_post.append(perspective_depsgraph_handler_splines)
    
    _depsgraph_handler_active_splines = True
    
    # The global 'previous_perspective_type_on_switch' is already initialized to 'NONE'
    # at the module level. We don't need to, and shouldn't, try to access bpy.context.scene here
    # to potentially change it during registration.
    # The EnumProperty's default and its update callback will handle the initial state correctly.

    print("Rogue Perspective AI Registered.")


def unregister():
    global _depsgraph_handler_active_splines
    _depsgraph_handler_active_splines = False # Disable handler first
    
    if perspective_depsgraph_handler_splines in bpy.app.handlers.depsgraph_update_post:
        bpy.app.handlers.depsgraph_update_post.remove(perspective_depsgraph_handler_splines)
    
    # Try to delete the PointerProperty from bpy.types.Scene
    if hasattr(bpy.types.Scene, 'perspective_tool_settings_splines'):
        try:
            del bpy.types.Scene.perspective_tool_settings_splines
        except Exception as e:
            print(f"Warning: Could not delete perspective_tool_settings_splines from Scene: {e}")

    for cls in reversed(classes_splines):
        if hasattr(bpy.utils, "unregister_class"): # Check if unregister_class is available
            try:
                bpy.utils.unregister_class(cls)
            except RuntimeError as e: # Catch common errors like "not registered"
                print(f"Warning: Could not unregister class {cls.__name__}: {e}")
            except Exception as e: # Catch any other unexpected errors
                print(f"Error unregistering class {cls.__name__}: {e}")
                
    print("Rogue Perspective AI Unregistered.")

if __name__ == "__main__":
    # This block is for testing within Blender's text editor.
    # It attempts to unregister first, then register.
    
    # Check if any class from the addon is registered as a proxy for the addon being loaded
    # A more robust check would be if bl_info["name"] is in bpy.context.preferences.addons
    # For simple script reload, checking a key class is often sufficient.
    is_registered_check_key_class = "Rogue_Perspective_AI_PT_main"
    
    # Attempt to unregister if it seems like the addon is already loaded
    # Look for the class in bpy.types (where registered classes reside)
    if hasattr(bpy.types, is_registered_check_key_class):
        print(f"'{is_registered_check_key_class}' found in bpy.types. Attempting unregister first...")
        try:
            unregister()
        except Exception as e:
            print(f"Error during pre-emptive unregistration in __main__: {e}")
            # It's possible unregister() itself might fail if state is inconsistent
            # from a previous bad load/unload. Forcing it might be risky.
            # For development, sometimes a Blender restart is cleaner if this gets messy.
    
    # Now, register the addon
    try:
        register()
    except Exception as e:
        print(f"Error during registration in __main__: {e}")